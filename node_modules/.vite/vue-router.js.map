{
  "version": 3,
  "sources": ["../vue-router/dist/vue-router.esm-bundler.js"],
  "sourcesContent": ["/*!\n  * vue-router v4.0.0-beta.2\n  * (c) 2020 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, warn as warn$1, inject, computed, unref, defineComponent, reactive, h, provide, ref, shallowRef, nextTick } from 'vue';\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vr = vue router\r\nhasSymbol\r\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' + name : name)\r\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' : '_vr_') + name;\r\n// rvlm = Router View Location Matched\r\nconst matchedRouteKey = PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location matched' : 'rvlm');\r\n// rvd = Router View Depth\r\nconst viewDepthKey = PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view depth' : 'rvd');\r\n// r = router\r\nconst routerKey = PolySymbol((process.env.NODE_ENV !== 'production') ? 'router' : 'r');\r\n// rt = route location\r\nconst routeLocationKey = PolySymbol((process.env.NODE_ENV !== 'production') ? 'route location' : 'rl');\n\nconst isBrowser = typeof window !== 'undefined';\n\nfunction isESModule(obj) {\r\n    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');\r\n}\r\nconst assign = Object.assign;\r\nfunction applyToParams(fn, params) {\r\n    const newParams = {};\r\n    for (const key in params) {\r\n        const value = params[key];\r\n        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\r\n    }\r\n    return newParams;\r\n}\r\nlet noop = () => { };\n\nconst TRAILING_SLASH_RE = /\\/$/;\r\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');\r\n/**\r\n * Transforms an URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\r\nfunction parseURL(parseQuery, location, currentLocation = '/') {\r\n    let path, query = {}, searchString = '', hash = '';\r\n    // Could use URL and URLSearchParams but IE 11 doesn't support it\r\n    const searchPos = location.indexOf('?');\r\n    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\r\n    if (searchPos > -1) {\r\n        path = location.slice(0, searchPos);\r\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\r\n        query = parseQuery(searchString);\r\n    }\r\n    if (hashPos > -1) {\r\n        path = path || location.slice(0, hashPos);\r\n        // keep the # character\r\n        hash = location.slice(hashPos, location.length);\r\n    }\r\n    // no search and no query\r\n    path = path != null ? path : location;\r\n    // empty path means a relative query or hash `?foo=f`, `#thing`\r\n    if (!path) {\r\n        path = currentLocation + path;\r\n    }\r\n    else if (path[0] !== '/') {\r\n        // relative to current location. Currently we only support simple relative\r\n        // but no `..`, `.`, or complex like `../.././..`. We will always leave the\r\n        // leading slash so we can safely append path\r\n        path = currentLocation.replace(/[^\\/]*$/, '') + path;\r\n    }\r\n    return {\r\n        fullPath: path + (searchString && '?') + searchString + hash,\r\n        path,\r\n        query,\r\n        hash,\r\n    };\r\n}\r\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\r\nfunction stringifyURL(stringifyQuery, location) {\r\n    let query = location.query ? stringifyQuery(location.query) : '';\r\n    return location.path + (query && '?') + query + (location.hash || '');\r\n}\r\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non\r\n * case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\r\nfunction stripBase(pathname, base) {\r\n    // no base or base is not found at the beginning\r\n    if (!base || pathname.toLowerCase().indexOf(base.toLowerCase()))\r\n        return pathname;\r\n    return pathname.slice(base.length) || '/';\r\n}\r\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a first {@link RouteLocation}\r\n * @param b second {@link RouteLocation}\r\n */\r\nfunction isSameRouteLocation(stringifyQuery, a, b) {\r\n    let aLastIndex = a.matched.length - 1;\r\n    let bLastIndex = b.matched.length - 1;\r\n    return (aLastIndex > -1 &&\r\n        aLastIndex === bLastIndex &&\r\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\r\n        isSameRouteLocationParams(a.params, b.params) &&\r\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\r\n        a.hash === b.hash);\r\n}\r\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a first {@link RouteRecord}\r\n * @param b second {@link RouteRecord}\r\n */\r\nfunction isSameRouteRecord(a, b) {\r\n    // since the original record has an undefined value for aliasOf\r\n    // but all aliases point to the original record, this will always compare\r\n    // the original record\r\n    return (a.aliasOf || a) === (b.aliasOf || b);\r\n}\r\nfunction isSameRouteLocationParams(a, b) {\r\n    if (Object.keys(a).length !== Object.keys(b).length)\r\n        return false;\r\n    for (let key in a) {\r\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isSameRouteLocationParamsValue(a, b) {\r\n    return Array.isArray(a)\r\n        ? isEquivalentArray(a, b)\r\n        : Array.isArray(b)\r\n            ? isEquivalentArray(b, a)\r\n            : a === b;\r\n}\r\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a array of values\r\n * @param b array of values or a single value\r\n */\r\nfunction isEquivalentArray(a, b) {\r\n    return Array.isArray(b)\r\n        ? a.length === b.length && a.every((value, i) => value === b[i])\r\n        : a.length === 1 && a[0] === b;\r\n}\n\nvar NavigationType;\r\n(function (NavigationType) {\r\n    NavigationType[\"pop\"] = \"pop\";\r\n    NavigationType[\"push\"] = \"push\";\r\n})(NavigationType || (NavigationType = {}));\r\nvar NavigationDirection;\r\n(function (NavigationDirection) {\r\n    NavigationDirection[\"back\"] = \"back\";\r\n    NavigationDirection[\"forward\"] = \"forward\";\r\n    NavigationDirection[\"unknown\"] = \"\";\r\n})(NavigationDirection || (NavigationDirection = {}));\r\n/**\r\n * Starting location for Histories\r\n */\r\nconst START = '';\r\n// Generic utils\r\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\r\nfunction normalizeBase(base) {\r\n    if (!base) {\r\n        if (isBrowser) {\r\n            // respect <base> tag\r\n            const baseEl = document.querySelector('base');\r\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\r\n            // strip full URL origin\r\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\r\n        }\r\n        else {\r\n            base = '/';\r\n        }\r\n    }\r\n    // ensure leading slash when it was removed by the regex above avoid leading\r\n    // slash with hash because the file could be read from the disk like file://\r\n    // and the leading slash would cause problems\r\n    if (base[0] !== '/' && base[0] !== '#')\r\n        base = '/' + base;\r\n    // remove the trailing slash so all other method can just do `base + fullPath`\r\n    // to build an href\r\n    return removeTrailingSlash(base);\r\n}\r\n// remove any character before the hash\r\nconst BEFORE_HASH_RE = /^[^#]+#/;\r\nfunction createHref(base, location) {\r\n    return base.replace(BEFORE_HASH_RE, '#') + location;\r\n}\n\nfunction warn(msg, ...args) {\r\n    console.warn('[Vue Router warn]: ' + msg, ...args);\r\n}\n\nfunction getElementPosition(el, offset) {\r\n    const docRect = document.documentElement.getBoundingClientRect();\r\n    const elRect = el.getBoundingClientRect();\r\n    return {\r\n        behavior: offset.behavior,\r\n        left: elRect.left - docRect.left - (offset.left || 0),\r\n        top: elRect.top - docRect.top - (offset.top || 0),\r\n    };\r\n}\r\nconst computeScrollPosition = () => ({\r\n    left: window.pageXOffset,\r\n    top: window.pageYOffset,\r\n});\r\nfunction scrollToPosition(position) {\r\n    let scrollToOptions;\r\n    if ('el' in position) {\r\n        let positionEl = position.el;\r\n        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\r\n        /**\r\n         * `id`s can accept pretty much any characters, including CSS combinators\r\n         * like `>` or `~`. It's still possible to retrieve elements using\r\n         * `document.getElementById('~')` but it needs to be escaped when using\r\n         * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n         * requirements for `id`s are them to be unique on the page and to not be\r\n         * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n         * be properly escaped for it to work with `querySelector`. We could check\r\n         * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n         * would make things inconsistent since they are valid characters for an\r\n         * `id` but would need to be escaped when using `querySelector`, breaking\r\n         * their usage and ending up in no selector returned. Selectors need to be\r\n         * escaped:\r\n         *\r\n         * - `#1-thing` becomes `#\\31 -thing`\r\n         * - `#with~symbols` becomes `#with\\\\~symbols`\r\n         *\r\n         * - More information about  the topic can be found at\r\n         *   https://mathiasbynens.be/notes/html5-id-class.\r\n         * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n         */\r\n        if ((process.env.NODE_ENV !== 'production') && typeof position.el === 'string') {\r\n            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\r\n                try {\r\n                    let foundEl = document.querySelector(position.el);\r\n                    if (isIdSelector && foundEl) {\r\n                        warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\r\n                        // return to avoid other warnings\r\n                        return;\r\n                    }\r\n                }\r\n                catch {\r\n                    warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\r\n                    // return to avoid other warnings\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        const el = typeof positionEl === 'string'\r\n            ? isIdSelector\r\n                ? document.getElementById(positionEl.slice(1))\r\n                : document.querySelector(positionEl)\r\n            : positionEl;\r\n        if (!el) {\r\n            (process.env.NODE_ENV !== 'production') && warn(`Couldn't find element using selector \"${position.el}\"`);\r\n            return;\r\n        }\r\n        scrollToOptions = getElementPosition(el, position);\r\n    }\r\n    else {\r\n        scrollToOptions = position;\r\n    }\r\n    if ('scrollBehavior' in document.documentElement.style)\r\n        window.scrollTo(scrollToOptions);\r\n    else {\r\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\r\n    }\r\n}\r\nfunction getScrollKey(path, delta) {\r\n    const position = history.state ? history.state.position - delta : -1;\r\n    return position + path;\r\n}\r\nconst scrollPositions = new Map();\r\nfunction saveScrollPosition(key, scrollPosition) {\r\n    scrollPositions.set(key, scrollPosition);\r\n}\r\nfunction getSavedScrollPosition(key) {\r\n    const scroll = scrollPositions.get(key);\r\n    // consume it so it's not used again\r\n    scrollPositions.delete(key);\r\n    return scroll;\r\n}\r\n// TODO: RFC about how to save scroll position\r\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\r\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\r\n//   // returns a scroll position that can be saved in history\r\n//   compute(): ScrollPositionEntry\r\n//   // can take an extended ScrollPositionEntry\r\n//   scroll(position: ScrollPosition): void\r\n// }\r\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\r\n//   compute: computeScroll,\r\n//   scroll: scrollToPosition,\r\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\r\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location\r\n */\r\nfunction createCurrentLocation(base, location) {\r\n    const { pathname, search, hash } = location;\r\n    // allows hash based url\r\n    const hashPos = base.indexOf('#');\r\n    if (hashPos > -1) {\r\n        // prepend the starting slash to hash so the url starts with /#\r\n        let pathFromHash = hash.slice(1);\r\n        if (pathFromHash[0] !== '/')\r\n            pathFromHash = '/' + pathFromHash;\r\n        return stripBase(pathFromHash, '');\r\n    }\r\n    const path = stripBase(pathname, base);\r\n    return path + search + hash;\r\n}\r\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\r\n    let listeners = [];\r\n    let teardowns = [];\r\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\r\n    // can trigger twice\r\n    let pauseState = null;\r\n    const popStateHandler = ({ state, }) => {\r\n        const to = createCurrentLocation(base, location);\r\n        const from = currentLocation.value;\r\n        const fromState = historyState.value;\r\n        let delta = 0;\r\n        if (state) {\r\n            currentLocation.value = to;\r\n            historyState.value = state;\r\n            // ignore the popstate and reset the pauseState\r\n            if (pauseState && pauseState === from) {\r\n                pauseState = null;\r\n                return;\r\n            }\r\n            delta = fromState ? state.position - fromState.position : 0;\r\n        }\r\n        else {\r\n            replace(to);\r\n        }\r\n        // console.log({ deltaFromCurrent })\r\n        // Here we could also revert the navigation by calling history.go(-delta)\r\n        // this listener will have to be adapted to not trigger again and to wait for the url\r\n        // to be updated before triggering the listeners. Some kind of validation function would also\r\n        // need to be passed to the listeners so the navigation can be accepted\r\n        // call all listeners\r\n        listeners.forEach(listener => {\r\n            listener(currentLocation.value, from, {\r\n                delta,\r\n                type: NavigationType.pop,\r\n                direction: delta\r\n                    ? delta > 0\r\n                        ? NavigationDirection.forward\r\n                        : NavigationDirection.back\r\n                    : NavigationDirection.unknown,\r\n            });\r\n        });\r\n    };\r\n    function pauseListeners() {\r\n        pauseState = currentLocation.value;\r\n    }\r\n    function listen(callback) {\r\n        // setup the listener and prepare teardown callbacks\r\n        listeners.push(callback);\r\n        const teardown = () => {\r\n            const index = listeners.indexOf(callback);\r\n            if (index > -1)\r\n                listeners.splice(index, 1);\r\n        };\r\n        teardowns.push(teardown);\r\n        return teardown;\r\n    }\r\n    function beforeUnloadListener() {\r\n        const { history } = window;\r\n        if (!history.state)\r\n            return;\r\n        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');\r\n    }\r\n    function destroy() {\r\n        for (const teardown of teardowns)\r\n            teardown();\r\n        teardowns = [];\r\n        window.removeEventListener('popstate', popStateHandler);\r\n        window.removeEventListener('beforeunload', beforeUnloadListener);\r\n    }\r\n    // setup the listeners and prepare teardown callbacks\r\n    window.addEventListener('popstate', popStateHandler);\r\n    window.addEventListener('beforeunload', beforeUnloadListener);\r\n    return {\r\n        pauseListeners,\r\n        listen,\r\n        destroy,\r\n    };\r\n}\r\n/**\r\n * Creates a state object\r\n */\r\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\r\n    return {\r\n        back,\r\n        current,\r\n        forward,\r\n        replaced,\r\n        position: window.history.length,\r\n        scroll: computeScroll ? computeScrollPosition() : null,\r\n    };\r\n}\r\nfunction useHistoryStateNavigation(base) {\r\n    const { history, location } = window;\r\n    // private variables\r\n    let currentLocation = {\r\n        value: createCurrentLocation(base, location),\r\n    };\r\n    let historyState = { value: history.state };\r\n    // build current history entry as this is a fresh navigation\r\n    if (!historyState.value) {\r\n        changeLocation(currentLocation.value, {\r\n            back: null,\r\n            current: currentLocation.value,\r\n            forward: null,\r\n            // the length is off by one, we need to decrease it\r\n            position: history.length - 1,\r\n            replaced: true,\r\n            // don't add a scroll as the user may have an anchor and we want\r\n            // scrollBehavior to be triggered without a saved position\r\n            scroll: null,\r\n        }, true);\r\n    }\r\n    function changeLocation(to, state, replace) {\r\n        const url = createBaseLocation() +\r\n            // preserve any existing query when base has a hash\r\n            (base.indexOf('#') > -1 && location.search\r\n                ? location.pathname + location.search + '#'\r\n                : base) +\r\n            to;\r\n        try {\r\n            // BROWSER QUIRK\r\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\r\n            history[replace ? 'replaceState' : 'pushState'](state, '', url);\r\n            historyState.value = state;\r\n        }\r\n        catch (err) {\r\n            warn('Error with push/replace State', err);\r\n            // Force the navigation, this also resets the call count\r\n            location[replace ? 'replace' : 'assign'](url);\r\n        }\r\n    }\r\n    function replace(to, data) {\r\n        const state = assign({}, history.state, buildState(historyState.value.back, \r\n        // keep back and forward entries but override current position\r\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\r\n        changeLocation(to, state, true);\r\n        currentLocation.value = to;\r\n    }\r\n    function push(to, data) {\r\n        // Add to current entry the information of where we are going\r\n        // as well as saving the current position\r\n        const currentState = assign({}, history.state, {\r\n            forward: to,\r\n            scroll: computeScrollPosition(),\r\n        });\r\n        changeLocation(currentState.current, currentState, true);\r\n        const state = assign({}, buildState(currentLocation.value, to, null), {\r\n            position: currentState.position + 1,\r\n        }, data);\r\n        changeLocation(to, state, false);\r\n        currentLocation.value = to;\r\n    }\r\n    return {\r\n        location: currentLocation,\r\n        state: historyState,\r\n        push,\r\n        replace,\r\n    };\r\n}\r\nfunction createWebHistory(base) {\r\n    base = normalizeBase(base);\r\n    const historyNavigation = useHistoryStateNavigation(base);\r\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\r\n    function go(delta, triggerListeners = true) {\r\n        if (!triggerListeners)\r\n            historyListeners.pauseListeners();\r\n        history.go(delta);\r\n    }\r\n    const routerHistory = assign({\r\n        // it's overridden right after\r\n        location: '',\r\n        base,\r\n        go,\r\n        createHref: createHref.bind(null, base),\r\n    }, historyNavigation, historyListeners);\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        get: () => historyNavigation.location.value,\r\n    });\r\n    Object.defineProperty(routerHistory, 'state', {\r\n        get: () => historyNavigation.state.value,\r\n    });\r\n    return routerHistory;\r\n}\n\n// TODO: verify base is working for SSR\r\n/**\r\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location.\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\r\nfunction createMemoryHistory(base = '') {\r\n    let listeners = [];\r\n    let queue = [START];\r\n    let position = 0;\r\n    function setLocation(location) {\r\n        position++;\r\n        if (position === queue.length) {\r\n            // we are at the end, we can simply append a new entry\r\n            queue.push(location);\r\n        }\r\n        else {\r\n            // we are in the middle, we remove everything from here in the queue\r\n            queue.splice(position);\r\n            queue.push(location);\r\n        }\r\n    }\r\n    function triggerListeners(to, from, { direction, delta }) {\r\n        const info = {\r\n            direction,\r\n            delta,\r\n            type: NavigationType.pop,\r\n        };\r\n        for (let callback of listeners) {\r\n            callback(to, from, info);\r\n        }\r\n    }\r\n    const routerHistory = {\r\n        // rewritten by Object.defineProperty\r\n        location: START,\r\n        state: {},\r\n        base,\r\n        createHref: createHref.bind(null, base),\r\n        replace(to) {\r\n            // remove current entry and decrement position\r\n            queue.splice(position--, 1);\r\n            setLocation(to);\r\n        },\r\n        push(to, data) {\r\n            setLocation(to);\r\n        },\r\n        listen(callback) {\r\n            listeners.push(callback);\r\n            return () => {\r\n                const index = listeners.indexOf(callback);\r\n                if (index > -1)\r\n                    listeners.splice(index, 1);\r\n            };\r\n        },\r\n        destroy() {\r\n            listeners = [];\r\n        },\r\n        go(delta, shouldTrigger = true) {\r\n            const from = this.location;\r\n            const direction = \r\n            // we are considering delta === 0 going forward, but in abstract mode\r\n            // using 0 for the delta doesn't make sense like it does in html5 where\r\n            // it reloads the page\r\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\r\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\r\n            if (shouldTrigger) {\r\n                triggerListeners(this.location, from, {\r\n                    direction,\r\n                    delta,\r\n                });\r\n            }\r\n        },\r\n    };\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        get: () => queue[position],\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a hash history.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname` or\r\n * `/` if at root. If there is a `base` tag in the `head`, its value will be\r\n * **ignored**.\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\r\nfunction createWebHashHistory(base) {\r\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\r\n    // for `file://`, directly use the pathname and ignore the base\r\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\r\n    base = location.host ? base || location.pathname : location.pathname;\r\n    // allow the user to provide a `#` in the middle: `/base/#/app`\r\n    if (base.indexOf('#') < 0)\r\n        base += '#';\r\n    if ((process.env.NODE_ENV !== 'production') && !base.endsWith('#/') && !base.endsWith('#')) {\r\n        warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\r\n    }\r\n    return createWebHistory(base);\r\n}\n\n/**\r\n * Encoding Rules \u2423 = Space Path: \u2423 \" < > # ? { } Query: \u2423 \" < > # & = Hash: \u2423 \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\r\n// const EXTRA_RESERVED_RE = /[!'()*]/g\r\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\r\nconst HASH_RE = /#/g; // %23\r\nconst AMPERSAND_RE = /&/g; // %26\r\nconst SLASH_RE = /\\//g; // %2F\r\nconst EQUAL_RE = /=/g; // %3D\r\nconst IM_RE = /\\?/g; // %3F\r\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\r\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\r\nconst ENC_CARET_RE = /%5E/g; // ^\r\nconst ENC_BACKTICK_RE = /%60/g; // `\r\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\r\nconst ENC_PIPE_RE = /%7C/g; // |\r\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\r\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction commonEncode(text) {\r\n    return encodeURI('' + text)\r\n        .replace(ENC_PIPE_RE, '|')\r\n        .replace(ENC_BRACKET_OPEN_RE, '[')\r\n        .replace(ENC_BRACKET_CLOSE_RE, ']');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeHash(text) {\r\n    return commonEncode(text)\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^');\r\n}\r\n/**\r\n * Encode characters that need to be encoded query keys and values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeQueryProperty(text) {\r\n    return commonEncode(text)\r\n        .replace(HASH_RE, '%23')\r\n        .replace(AMPERSAND_RE, '%26')\r\n        .replace(EQUAL_RE, '%3D')\r\n        .replace(ENC_BACKTICK_RE, '`')\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodePath(text) {\r\n    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeParam(text) {\r\n    return encodePath(text).replace(SLASH_RE, '%2F');\r\n}\r\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\r\nfunction decode(text) {\r\n    try {\r\n        return decodeURIComponent('' + text);\r\n    }\r\n    catch (err) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`Error decoding \"${text}\". Using original value`);\r\n    }\r\n    return '' + text;\r\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\r\nfunction parseQuery(search) {\r\n    const query = {};\r\n    // avoid creating an object with an empty key and empty value\r\n    // because of split('&')\r\n    if (search === '' || search === '?')\r\n        return query;\r\n    const hasLeadingIM = search[0] === '?';\r\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\r\n    for (let i = 0; i < searchParams.length; ++i) {\r\n        let [key, rawValue] = searchParams[i].split('=');\r\n        key = decode(key);\r\n        // avoid decoding null\r\n        let value = rawValue == null ? null : decode(rawValue);\r\n        if (key in query) {\r\n            // an extra variable for ts types\r\n            let currentValue = query[key];\r\n            if (!Array.isArray(currentValue)) {\r\n                currentValue = query[key] = [currentValue];\r\n            }\r\n            currentValue.push(value);\r\n        }\r\n        else {\r\n            query[key] = value;\r\n        }\r\n    }\r\n    return query;\r\n}\r\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\r\nfunction stringifyQuery(query) {\r\n    let search = '';\r\n    for (let key in query) {\r\n        if (search.length)\r\n            search += '&';\r\n        const value = query[key];\r\n        key = encodeQueryProperty(key);\r\n        if (value == null) {\r\n            // only null adds the value\r\n            if (value !== undefined)\r\n                search += key;\r\n            continue;\r\n        }\r\n        // keep null values\r\n        let values = Array.isArray(value)\r\n            ? value.map(v => v && encodeQueryProperty(v))\r\n            : [value && encodeQueryProperty(value)];\r\n        for (let i = 0; i < values.length; i++) {\r\n            // only append & with i > 0\r\n            search += (i ? '&' : '') + key;\r\n            if (values[i] != null)\r\n                search += ('=' + values[i]);\r\n        }\r\n    }\r\n    return search;\r\n}\r\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\r\nfunction normalizeQuery(query) {\r\n    const normalizedQuery = {};\r\n    for (let key in query) {\r\n        let value = query[key];\r\n        if (value !== undefined) {\r\n            normalizedQuery[key] = Array.isArray(value)\r\n                ? value.map(v => (v == null ? null : '' + v))\r\n                : value == null\r\n                    ? value\r\n                    : '' + value;\r\n        }\r\n    }\r\n    return normalizedQuery;\r\n}\n\nfunction isRouteLocation(route) {\r\n    return typeof route === 'string' || (route && typeof route === 'object');\r\n}\r\nfunction isRouteName(name) {\r\n    return typeof name === 'string' || typeof name === 'symbol';\r\n}\n\nconst START_LOCATION_NORMALIZED = {\r\n    path: '/',\r\n    name: undefined,\r\n    params: {},\r\n    query: {},\r\n    hash: '',\r\n    fullPath: '/',\r\n    matched: [],\r\n    meta: {},\r\n    redirectedFrom: undefined,\r\n};\n\nconst NavigationFailureSymbol = PolySymbol((process.env.NODE_ENV !== 'production') ? 'navigation failure' : 'nf');\r\nvar NavigationFailureType;\r\n(function (NavigationFailureType) {\r\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\r\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\r\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\r\n})(NavigationFailureType || (NavigationFailureType = {}));\r\n// DEV only debug messages\r\nconst ErrorTypeMessages = {\r\n    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {\r\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\r\n            ? '\\nwhile being at\\n' + JSON.stringify(currentLocation)\r\n            : ''}`;\r\n    },\r\n    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\r\n        return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\r\n    },\r\n    [4 /* NAVIGATION_ABORTED */]({ from, to }) {\r\n        return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\r\n    },\r\n    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {\r\n        return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\r\n    },\r\n    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {\r\n        return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\r\n    },\r\n};\r\nfunction createRouterError(type, params) {\r\n    if ((process.env.NODE_ENV !== 'production') || !true) {\r\n        return assign(new Error(ErrorTypeMessages[type](params)), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n    else {\r\n        return assign(new Error(), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n}\r\nfunction isNavigationFailure(error, type) {\r\n    return (error instanceof Error &&\r\n        NavigationFailureSymbol in error &&\r\n        (type == null || !!(error.type & type)));\r\n}\r\nconst propertiesToLog = ['params', 'query', 'hash'];\r\nfunction stringifyRoute(to) {\r\n    if (typeof to === 'string')\r\n        return to;\r\n    if ('path' in to)\r\n        return to.path;\r\n    const location = {};\r\n    for (const key of propertiesToLog) {\r\n        if (key in to)\r\n            location[key] = to[key];\r\n    }\r\n    return JSON.stringify(location, null, 2);\r\n}\n\n// default pattern for a param: non greedy everything but /\r\nconst BASE_PARAM_PATTERN = '[^/]+?';\r\nconst BASE_PATH_PARSER_OPTIONS = {\r\n    sensitive: false,\r\n    strict: false,\r\n    start: true,\r\n    end: true,\r\n};\r\n// Special Regex characters that must be escaped in static tokens\r\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\r\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\r\nfunction tokensToParser(segments, extraOptions) {\r\n    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\r\n    // the amount of scores is the same as the length of segments except for the root segment \"/\"\r\n    let score = [];\r\n    // the regexp as a string\r\n    let pattern = options.start ? '^' : '';\r\n    // extracted keys\r\n    const keys = [];\r\n    for (const segment of segments) {\r\n        // the root segment needs special treatment\r\n        const segmentScores = segment.length ? [] : [90 /* Root */];\r\n        // allow trailing slash\r\n        if (options.strict && !segment.length)\r\n            pattern += '/';\r\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\r\n            const token = segment[tokenIndex];\r\n            // resets the score if we are inside a sub segment /:a-other-:b\r\n            let subSegmentScore = 40 /* Segment */ +\r\n                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\r\n            if (token.type === 0 /* Static */) {\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    pattern += '/';\r\n                pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\r\n                subSegmentScore += 40 /* Static */;\r\n            }\r\n            else if (token.type === 1 /* Param */) {\r\n                const { value, repeatable, optional, regexp } = token;\r\n                keys.push({\r\n                    name: value,\r\n                    repeatable,\r\n                    optional,\r\n                });\r\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\r\n                // the user provided a custom regexp /:id(\\\\d+)\r\n                if (re !== BASE_PARAM_PATTERN) {\r\n                    subSegmentScore += 10 /* BonusCustomRegExp */;\r\n                    // make sure the regexp is valid before using it\r\n                    try {\r\n                        new RegExp(`(${re})`);\r\n                    }\r\n                    catch (err) {\r\n                        throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` +\r\n                            err.message);\r\n                    }\r\n                }\r\n                // when we repeat we must take care of the repeating leading slash\r\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    subPattern = optional ? `(?:/${subPattern})` : '/' + subPattern;\r\n                if (optional)\r\n                    subPattern += '?';\r\n                pattern += subPattern;\r\n                subSegmentScore += 20 /* Dynamic */;\r\n                if (optional)\r\n                    subSegmentScore += -8 /* BonusOptional */;\r\n                if (repeatable)\r\n                    subSegmentScore += -20 /* BonusRepeatable */;\r\n                if (re === '.*')\r\n                    subSegmentScore += -50 /* BonusWildcard */;\r\n            }\r\n            segmentScores.push(subSegmentScore);\r\n        }\r\n        // an empty array like /home/ -> [[{home}], []]\r\n        // if (!segment.length) pattern += '/'\r\n        score.push(segmentScores);\r\n    }\r\n    // only apply the strict bonus to the last score\r\n    if (options.strict && options.end) {\r\n        const i = score.length - 1;\r\n        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\r\n    }\r\n    // TODO: dev only warn double trailing slash\r\n    if (!options.strict)\r\n        pattern += '/?';\r\n    if (options.end)\r\n        pattern += '$';\r\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\r\n    else if (options.strict)\r\n        pattern += '(?:/|$)';\r\n    const re = new RegExp(pattern, options.sensitive ? '' : 'i');\r\n    function parse(path) {\r\n        const match = path.match(re);\r\n        const params = {};\r\n        if (!match)\r\n            return null;\r\n        for (let i = 1; i < match.length; i++) {\r\n            const value = match[i] || '';\r\n            const key = keys[i - 1];\r\n            params[key.name] = value && key.repeatable ? value.split('/') : value;\r\n        }\r\n        return params;\r\n    }\r\n    function stringify(params) {\r\n        let path = '';\r\n        // for optional parameters to allow to be empty\r\n        let avoidDuplicatedSlash = false;\r\n        for (const segment of segments) {\r\n            if (!avoidDuplicatedSlash || path[path.length - 1] !== '/')\r\n                path += '/';\r\n            avoidDuplicatedSlash = false;\r\n            for (const token of segment) {\r\n                if (token.type === 0 /* Static */) {\r\n                    path += token.value;\r\n                }\r\n                else if (token.type === 1 /* Param */) {\r\n                    const { value, repeatable, optional } = token;\r\n                    const param = value in params ? params[value] : '';\r\n                    if (Array.isArray(param) && !repeatable)\r\n                        throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\r\n                    const text = Array.isArray(param) ? param.join('/') : param;\r\n                    if (!text) {\r\n                        // do not append a slash on the next iteration\r\n                        if (optional)\r\n                            avoidDuplicatedSlash = true;\r\n                        else\r\n                            throw new Error(`Missing required param \"${value}\"`);\r\n                    }\r\n                    path += text;\r\n                }\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n    return {\r\n        re,\r\n        score,\r\n        keys,\r\n        parse,\r\n        stringify,\r\n    };\r\n}\r\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\r\nfunction compareScoreArray(a, b) {\r\n    let i = 0;\r\n    while (i < a.length && i < b.length) {\r\n        const diff = b[i] - a[i];\r\n        // only keep going if diff === 0\r\n        if (diff)\r\n            return diff;\r\n        i++;\r\n    }\r\n    // if the last subsegment was Static, the shorter segments should be sorted first\r\n    // otherwise sort the longest segment first\r\n    if (a.length < b.length) {\r\n        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? -1\r\n            : 1;\r\n    }\r\n    else if (a.length > b.length) {\r\n        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? 1\r\n            : -1;\r\n    }\r\n    return 0;\r\n}\r\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\r\nfunction comparePathParserScore(a, b) {\r\n    let i = 0;\r\n    const aScore = a.score;\r\n    const bScore = b.score;\r\n    while (i < aScore.length && i < bScore.length) {\r\n        const comp = compareScoreArray(aScore[i], bScore[i]);\r\n        // do not return if both are equal\r\n        if (comp)\r\n            return comp;\r\n        i++;\r\n    }\r\n    // if a and b share the same score entries but b has more, sort b first\r\n    return bScore.length - aScore.length;\r\n    // this is the ternary version\r\n    // return aScore.length < bScore.length\r\n    //   ? 1\r\n    //   : aScore.length > bScore.length\r\n    //   ? -1\r\n    //   : 0\r\n}\n\nconst ROOT_TOKEN = {\r\n    type: 0 /* Static */,\r\n    value: '',\r\n};\r\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\r\n// After some profiling, the cache seems to be unnecessary because tokenizePath\r\n// (the slowest part of adding a route) is very fast\r\n// const tokenCache = new Map<string, Token[][]>()\r\nfunction tokenizePath(path) {\r\n    if (!path)\r\n        return [[]];\r\n    if (path === '/')\r\n        return [[ROOT_TOKEN]];\r\n    // remove the leading slash\r\n    if (path[0] !== '/')\r\n        throw new Error('A non-empty path must start with \"/\"');\r\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\r\n    function crash(message) {\r\n        throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\r\n    }\r\n    let state = 0 /* Static */;\r\n    let previousState = state;\r\n    const tokens = [];\r\n    // the segment will always be valid because we get into the initial state\r\n    // with the leading /\r\n    let segment;\r\n    function finalizeSegment() {\r\n        if (segment)\r\n            tokens.push(segment);\r\n        segment = [];\r\n    }\r\n    // index on the path\r\n    let i = 0;\r\n    // char at index\r\n    let char;\r\n    // buffer of the value read\r\n    let buffer = '';\r\n    // custom regexp for a param\r\n    let customRe = '';\r\n    function consumeBuffer() {\r\n        if (!buffer)\r\n            return;\r\n        if (state === 0 /* Static */) {\r\n            segment.push({\r\n                type: 0 /* Static */,\r\n                value: buffer,\r\n            });\r\n        }\r\n        else if (state === 1 /* Param */ ||\r\n            state === 2 /* ParamRegExp */ ||\r\n            state === 3 /* ParamRegExpEnd */) {\r\n            if (segment.length > 1 && (char === '*' || char === '+'))\r\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\r\n            segment.push({\r\n                type: 1 /* Param */,\r\n                value: buffer,\r\n                regexp: customRe,\r\n                repeatable: char === '*' || char === '+',\r\n                optional: char === '*' || char === '?',\r\n            });\r\n        }\r\n        else {\r\n            crash('Invalid state to consume buffer');\r\n        }\r\n        buffer = '';\r\n    }\r\n    function addCharToBuffer() {\r\n        buffer += char;\r\n    }\r\n    while (i < path.length) {\r\n        char = path[i++];\r\n        if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\r\n            previousState = state;\r\n            state = 4 /* EscapeNext */;\r\n            continue;\r\n        }\r\n        switch (state) {\r\n            case 0 /* Static */:\r\n                if (char === '/') {\r\n                    if (buffer) {\r\n                        consumeBuffer();\r\n                    }\r\n                    finalizeSegment();\r\n                }\r\n                else if (char === ':') {\r\n                    consumeBuffer();\r\n                    state = 1 /* Param */;\r\n                }\r\n                else {\r\n                    addCharToBuffer();\r\n                }\r\n                break;\r\n            case 4 /* EscapeNext */:\r\n                addCharToBuffer();\r\n                state = previousState;\r\n                break;\r\n            case 1 /* Param */:\r\n                if (char === '(') {\r\n                    state = 2 /* ParamRegExp */;\r\n                    customRe = '';\r\n                }\r\n                else if (VALID_PARAM_RE.test(char)) {\r\n                    addCharToBuffer();\r\n                }\r\n                else {\r\n                    consumeBuffer();\r\n                    state = 0 /* Static */;\r\n                    // go back one character if we were not modifying\r\n                    if (char !== '*' && char !== '?' && char !== '+')\r\n                        i--;\r\n                }\r\n                break;\r\n            case 2 /* ParamRegExp */:\r\n                if (char === ')') {\r\n                    // handle the escaped )\r\n                    if (customRe[customRe.length - 1] == '\\\\')\r\n                        customRe = customRe.slice(0, -1) + char;\r\n                    else\r\n                        state = 3 /* ParamRegExpEnd */;\r\n                }\r\n                else {\r\n                    customRe += char;\r\n                }\r\n                break;\r\n            case 3 /* ParamRegExpEnd */:\r\n                // same as finalizing a param\r\n                consumeBuffer();\r\n                state = 0 /* Static */;\r\n                // go back one character if we were not modifying\r\n                if (char !== '*' && char !== '?' && char !== '+')\r\n                    i--;\r\n                break;\r\n            default:\r\n                crash('Unknown state');\r\n                break;\r\n        }\r\n    }\r\n    if (state === 2 /* ParamRegExp */)\r\n        crash(`Unfinished custom RegExp for param \"${buffer}\"`);\r\n    consumeBuffer();\r\n    finalizeSegment();\r\n    // tokenCache.set(path, tokens)\r\n    return tokens;\r\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\r\n    const parser = tokensToParser(tokenizePath(record.path), options);\r\n    // warn against params with the same name\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const existingKeys = new Set();\r\n        for (const key of parser.keys) {\r\n            if (existingKeys.has(key.name))\r\n                warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\r\n            existingKeys.add(key.name);\r\n        }\r\n    }\r\n    const matcher = assign(parser, {\r\n        record,\r\n        parent,\r\n        // these needs to be populated by the parent\r\n        children: [],\r\n        alias: [],\r\n    });\r\n    if (parent) {\r\n        // both are aliases or both are not aliases\r\n        // we don't want to mix them because the order is used when\r\n        // passing originalRecord in Matcher.addRoute\r\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\r\n            parent.children.push(matcher);\r\n    }\r\n    return matcher;\r\n}\n\nfunction createRouterMatcher(routes, globalOptions) {\r\n    // normalized ordered array of matchers\r\n    const matchers = [];\r\n    const matcherMap = new Map();\r\n    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\r\n    function getRecordMatcher(name) {\r\n        return matcherMap.get(name);\r\n    }\r\n    function addRoute(record, parent, originalRecord) {\r\n        // used later on to remove by name\r\n        let isRootAdd = !originalRecord;\r\n        let mainNormalizedRecord = normalizeRouteRecord(record);\r\n        // we might be the child of an alias\r\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\r\n        const options = mergeOptions(globalOptions, record);\r\n        // generate an array of records to correctly handle aliases\r\n        const normalizedRecords = [\r\n            mainNormalizedRecord,\r\n        ];\r\n        if ('alias' in record) {\r\n            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\r\n            for (const alias of aliases) {\r\n                normalizedRecords.push(assign({}, mainNormalizedRecord, {\r\n                    // this allows us to hold a copy of the `components` option\r\n                    // so that async components cache is hold on the original record\r\n                    components: originalRecord\r\n                        ? originalRecord.record.components\r\n                        : mainNormalizedRecord.components,\r\n                    path: alias,\r\n                    // we might be the child of an alias\r\n                    aliasOf: originalRecord\r\n                        ? originalRecord.record\r\n                        : mainNormalizedRecord,\r\n                }));\r\n            }\r\n        }\r\n        let matcher;\r\n        let originalMatcher;\r\n        for (const normalizedRecord of normalizedRecords) {\r\n            let { path } = normalizedRecord;\r\n            // Build up the path for nested routes if the child isn't an absolute\r\n            // route. Only add the / delimiter if the child path isn't empty and if the\r\n            // parent path doesn't have a trailing slash\r\n            if (parent && path[0] !== '/') {\r\n                let parentPath = parent.record.path;\r\n                let connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\r\n                normalizedRecord.path =\r\n                    parent.record.path + (path && connectingSlash + path);\r\n            }\r\n            // create the object before hand so it can be passed to children\r\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\r\n            if ((process.env.NODE_ENV !== 'production') && parent && path[0] === '/')\r\n                checkMissingParamsInAbsolutePath(matcher, parent);\r\n            // if we are an alias we must tell the original record that we exist\r\n            // so we can be removed\r\n            if (originalRecord) {\r\n                originalRecord.alias.push(matcher);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkSameParams(originalRecord, matcher);\r\n                }\r\n            }\r\n            else {\r\n                // otherwise, the first record is the original and others are aliases\r\n                originalMatcher = originalMatcher || matcher;\r\n                if (originalMatcher !== matcher)\r\n                    originalMatcher.alias.push(matcher);\r\n                // remove the route if named and only for the top record (avoid in nested calls)\r\n                // this works because the original record is the first one\r\n                if (isRootAdd && record.name && !isAliasRecord(matcher))\r\n                    removeRoute(record.name);\r\n            }\r\n            if ('children' in mainNormalizedRecord) {\r\n                let children = mainNormalizedRecord.children;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\r\n                }\r\n            }\r\n            // if there was no original record, then the first one was not an alias and all\r\n            // other alias (if any) need to reference this record when adding children\r\n            originalRecord = originalRecord || matcher;\r\n            insertMatcher(matcher);\r\n        }\r\n        return originalMatcher\r\n            ? () => {\r\n                // since other matchers are aliases, they should be removed by the original matcher\r\n                removeRoute(originalMatcher);\r\n            }\r\n            : noop;\r\n    }\r\n    function removeRoute(matcherRef) {\r\n        if (isRouteName(matcherRef)) {\r\n            const matcher = matcherMap.get(matcherRef);\r\n            if (matcher) {\r\n                matcherMap.delete(matcherRef);\r\n                matchers.splice(matchers.indexOf(matcher), 1);\r\n                matcher.children.forEach(removeRoute);\r\n                matcher.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n        else {\r\n            let index = matchers.indexOf(matcherRef);\r\n            if (index > -1) {\r\n                matchers.splice(index, 1);\r\n                if (matcherRef.record.name)\r\n                    matcherMap.delete(matcherRef.record.name);\r\n                matcherRef.children.forEach(removeRoute);\r\n                matcherRef.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matchers;\r\n    }\r\n    function insertMatcher(matcher) {\r\n        let i = 0;\r\n        // console.log('i is', { i })\r\n        while (i < matchers.length &&\r\n            comparePathParserScore(matcher, matchers[i]) >= 0)\r\n            i++;\r\n        // console.log('END i is', { i })\r\n        // while (i < matchers.length && matcher.score <= matchers[i].score) i++\r\n        matchers.splice(i, 0, matcher);\r\n        // only add the original record to the name map\r\n        if (matcher.record.name && !isAliasRecord(matcher))\r\n            matcherMap.set(matcher.record.name, matcher);\r\n    }\r\n    /**\r\n     * Resolves a location. Gives access to the route record that corresponds to the actual path as well as filling the corresponding params objects\r\n     *\r\n     * @param location - MatcherLocationRaw to resolve to a url\r\n     * @param currentLocation - MatcherLocation of the current location\r\n     */\r\n    function resolve(location, currentLocation) {\r\n        let matcher;\r\n        let params = {};\r\n        let path;\r\n        let name;\r\n        if ('name' in location && location.name) {\r\n            matcher = matcherMap.get(location.name);\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                });\r\n            name = matcher.record.name;\r\n            params = assign(\r\n            // paramsFromLocation is a new object\r\n            paramsFromLocation(currentLocation.params, matcher.keys.map(k => k.name)), location.params);\r\n            // throws if cannot be stringified\r\n            path = matcher.stringify(params);\r\n        }\r\n        else if ('path' in location) {\r\n            // no need to resolve the path with the matcher as it was provided\r\n            // this also allows the user to control the encoding\r\n            path = location.path;\r\n            if ((process.env.NODE_ENV !== 'production') && path[0] !== '/') {\r\n                warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`);\r\n            }\r\n            matcher = matchers.find(m => m.re.test(path));\r\n            // matcher should have a value after the loop\r\n            if (matcher) {\r\n                // TODO: dev warning of unused params if provided\r\n                params = matcher.parse(path);\r\n                name = matcher.record.name;\r\n            }\r\n            // location is a relative path\r\n        }\r\n        else {\r\n            // match by name or path of current route\r\n            matcher = currentLocation.name\r\n                ? matcherMap.get(currentLocation.name)\r\n                : matchers.find(m => m.re.test(currentLocation.path));\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                    currentLocation,\r\n                });\r\n            name = matcher.record.name;\r\n            // since we are navigating to the same location, we don't need to pick the\r\n            // params like when `name` is provided\r\n            params = assign({}, currentLocation.params, location.params);\r\n            path = matcher.stringify(params);\r\n        }\r\n        const matched = [];\r\n        let parentMatcher = matcher;\r\n        while (parentMatcher) {\r\n            // reversed order so parents are at the beginning\r\n            matched.unshift(parentMatcher.record);\r\n            parentMatcher = parentMatcher.parent;\r\n        }\r\n        return {\r\n            name,\r\n            path,\r\n            params,\r\n            matched,\r\n            meta: mergeMetaFields(matched),\r\n        };\r\n    }\r\n    // add initial routes\r\n    routes.forEach(route => addRoute(route));\r\n    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\r\n}\r\nfunction paramsFromLocation(params, keys) {\r\n    let newParams = {};\r\n    for (let key of keys) {\r\n        if (key in params)\r\n            newParams[key] = params[key];\r\n    }\r\n    return newParams;\r\n}\r\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\r\nfunction normalizeRouteRecord(record) {\r\n    return {\r\n        path: record.path,\r\n        redirect: record.redirect,\r\n        name: record.name,\r\n        meta: record.meta || {},\r\n        aliasOf: undefined,\r\n        beforeEnter: record.beforeEnter,\r\n        props: normalizeRecordProps(record),\r\n        children: record.children || [],\r\n        instances: {},\r\n        leaveGuards: [],\r\n        updateGuards: [],\r\n        enterCallbacks: {},\r\n        components: 'components' in record\r\n            ? record.components || {}\r\n            : { default: record.component },\r\n    };\r\n}\r\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\r\nfunction normalizeRecordProps(record) {\r\n    const propsObject = {};\r\n    // props does not exist on redirect records but we can set false directly\r\n    const props = record.props || false;\r\n    if ('component' in record) {\r\n        propsObject.default = props;\r\n    }\r\n    else {\r\n        // NOTE: we could also allow a function to be applied to every component.\r\n        // Would need user feedback for use cases\r\n        for (let name in record.components)\r\n            propsObject[name] = typeof props === 'boolean' ? props : props[name];\r\n    }\r\n    return propsObject;\r\n}\r\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\r\nfunction isAliasRecord(record) {\r\n    while (record) {\r\n        if (record.record.aliasOf)\r\n            return true;\r\n        record = record.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched array of matched records\r\n */\r\nfunction mergeMetaFields(matched) {\r\n    return matched.reduce((meta, record) => assign(meta, record.meta), {});\r\n}\r\nfunction mergeOptions(defaults, partialOptions) {\r\n    let options = {};\r\n    for (let key in defaults) {\r\n        options[key] =\r\n            key in partialOptions ? partialOptions[key] : defaults[key];\r\n    }\r\n    return options;\r\n}\r\nfunction isSameParam(a, b) {\r\n    return (a.name === b.name &&\r\n        a.optional === b.optional &&\r\n        a.repeatable === b.repeatable);\r\n}\r\nfunction checkSameParams(a, b) {\r\n    for (let key of a.keys) {\r\n        if (!b.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n    for (let key of b.keys) {\r\n        if (!a.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n}\r\nfunction checkMissingParamsInAbsolutePath(record, parent) {\r\n    for (let key of parent.keys) {\r\n        if (!record.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\r\n    }\r\n}\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\r\nfunction useCallbacks() {\r\n    let handlers = [];\r\n    function add(handler) {\r\n        handlers.push(handler);\r\n        return () => {\r\n            const i = handlers.indexOf(handler);\r\n            if (i > -1)\r\n                handlers.splice(i, 1);\r\n        };\r\n    }\r\n    function reset() {\r\n        handlers = [];\r\n    }\r\n    return {\r\n        add,\r\n        list: () => handlers,\r\n        reset,\r\n    };\r\n}\n\n/**\r\n * Add a navigation guard that triggers whenever the current location is\r\n * left. Similarly to {@link beforeRouteLeave}, it has access to the\r\n * component instance as `this`.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteLeave(leaveGuard) {\r\n    const instance = getCurrentInstance();\r\n    if (!instance) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn$1('onBeforeRouteLeave must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn$1('onBeforeRouteLeave must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    activeRecord.leaveGuards.push(\r\n    // @ts-ignore do we even want to allow that? Passing the context in a composition api hook doesn't make sense\r\n    leaveGuard.bind(instance.proxy));\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the current location is\r\n * updated. Similarly to {@link beforeRouteUpdate}, it has access to the\r\n * component instance as `this`.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteUpdate(updateGuard) {\r\n    const instance = getCurrentInstance();\r\n    if (!instance) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn$1('onBeforeRouteUpdate must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn$1('onBeforeRouteUpdate must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    activeRecord.updateGuards.push(\r\n    // @ts-ignore do we even want to allow that? Passing the context in a composition api hook doesn't make sense\r\n    updateGuard.bind(instance.proxy));\r\n}\r\nfunction guardToPromiseFn(guard, to, from, record, name) {\r\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\r\n    const enterCallbackArray = record &&\r\n        // name is defined if record is because of the function overload\r\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\r\n    return () => new Promise((resolve, reject) => {\r\n        const next = (valid) => {\r\n            if (valid === false)\r\n                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\r\n                    from,\r\n                    to,\r\n                }));\r\n            else if (valid instanceof Error) {\r\n                reject(valid);\r\n            }\r\n            else if (isRouteLocation(valid)) {\r\n                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\r\n                    from: to,\r\n                    to: valid,\r\n                }));\r\n            }\r\n            else {\r\n                if (enterCallbackArray &&\r\n                    // since enterCallbackArray is truthy, both record and name also are\r\n                    record.enterCallbacks[name] === enterCallbackArray &&\r\n                    typeof valid === 'function')\r\n                    enterCallbackArray.push(valid);\r\n                resolve();\r\n            }\r\n        };\r\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\r\n        let guardCall = Promise.resolve(guard.call(record && record.instances[name], to, from, (process.env.NODE_ENV !== 'production') ? canOnlyBeCalledOnce(next, to, from) : next));\r\n        if (guard.length < 3)\r\n            guardCall.then(next);\r\n        guardCall.catch(err => reject(err));\r\n    });\r\n}\r\nfunction canOnlyBeCalledOnce(next, to, from) {\r\n    let called = 0;\r\n    return function () {\r\n        if (called++ === 1)\r\n            warn$1(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\r\n        if (called === 1)\r\n            next.apply(null, arguments);\r\n    };\r\n}\r\nfunction extractComponentsGuards(matched, guardType, to, from) {\r\n    const guards = [];\r\n    for (const record of matched) {\r\n        for (const name in record.components) {\r\n            let rawComponent = record.components[name];\r\n            // warn if user wrote import('/component.vue') instead of () => import('./component.vue')\r\n            if ((process.env.NODE_ENV !== 'production') && 'then' in rawComponent) {\r\n                warn$1(`Component \"${name}\" in record with path \"${record.path}\" is a Promise instead of a function that returns a Promise. Did you write \"import('./MyPage.vue')\" instead of \"() => import('./MyPage.vue')\"? This will break in production if not fixed.`);\r\n                let promise = rawComponent;\r\n                rawComponent = () => promise;\r\n            }\r\n            // skip update and leave guards if the route component is not mounted\r\n            if (guardType !== 'beforeRouteEnter' && !record.instances[name])\r\n                continue;\r\n            if (isRouteComponent(rawComponent)) {\r\n                // __vccOpts is added by vue-class-component and contain the regular options\r\n                let options = rawComponent.__vccOpts || rawComponent;\r\n                const guard = options[guardType];\r\n                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\r\n            }\r\n            else {\r\n                // start requesting the chunk already\r\n                let componentPromise = rawComponent();\r\n                if ((process.env.NODE_ENV !== 'production') && !('catch' in componentPromise)) {\r\n                    warn$1(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\r\n                    componentPromise = Promise.resolve(componentPromise);\r\n                }\r\n                else {\r\n                    componentPromise = componentPromise.catch(() => null);\r\n                }\r\n                guards.push(() => componentPromise.then(resolved => {\r\n                    if (!resolved)\r\n                        return Promise.reject(new Error(`Couldn't resolve component \"${name}\" for the following record with path \"${record.path}\"`));\r\n                    const resolvedComponent = isESModule(resolved)\r\n                        ? resolved.default\r\n                        : resolved;\r\n                    // replace the function with the resolved component\r\n                    record.components[name] = resolvedComponent;\r\n                    // @ts-ignore: the options types are not propagated to Component\r\n                    const guard = resolvedComponent[guardType];\r\n                    return guard && guardToPromiseFn(guard, to, from, record, name)();\r\n                }));\r\n            }\r\n        }\r\n    }\r\n    return guards;\r\n}\r\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n * @param component\r\n */\r\nfunction isRouteComponent(component) {\r\n    return (typeof component === 'object' ||\r\n        'displayName' in component ||\r\n        'props' in component ||\r\n        '__vccOpts' in component);\r\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\r\n// `isExactActive` behavior should go through an RFC\r\nfunction useLink(props) {\r\n    const router = inject(routerKey);\r\n    const currentRoute = inject(routeLocationKey);\r\n    const route = computed(() => router.resolve(unref(props.to)));\r\n    const activeRecordIndex = computed(() => {\r\n        let { matched } = route.value;\r\n        let { length } = matched;\r\n        const routeMatched = matched[length - 1];\r\n        let currentMatched = currentRoute.matched;\r\n        if (!routeMatched || !currentMatched.length)\r\n            return -1;\r\n        let index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\r\n        if (index > -1)\r\n            return index;\r\n        // possible parent record\r\n        let parentRecordPath = getOriginalPath(matched[length - 2]);\r\n        return (\r\n        // we are dealing with nested routes\r\n        length > 1 &&\r\n            // if the have the same path, this link is referring to the empty child\r\n            // are we currently are on a different child of the same parent\r\n            getOriginalPath(routeMatched) === parentRecordPath &&\r\n            // avoid comparing the child with its parent\r\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\r\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\r\n            : index);\r\n    });\r\n    const isActive = computed(() => activeRecordIndex.value > -1 &&\r\n        includesParams(currentRoute.params, route.value.params));\r\n    const isExactActive = computed(() => activeRecordIndex.value > -1 &&\r\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\r\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\r\n    function navigate(e = {}) {\r\n        if (guardEvent(e))\r\n            return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to));\r\n        return Promise.resolve();\r\n    }\r\n    return {\r\n        route,\r\n        href: computed(() => route.value.href),\r\n        isActive,\r\n        isExactActive,\r\n        navigate,\r\n    };\r\n}\r\nconst RouterLinkImpl = defineComponent({\r\n    name: 'RouterLink',\r\n    props: {\r\n        to: {\r\n            type: [String, Object],\r\n            required: true,\r\n        },\r\n        activeClass: String,\r\n        // inactiveClass: String,\r\n        exactActiveClass: String,\r\n        custom: Boolean,\r\n    },\r\n    setup(props, { slots, attrs }) {\r\n        const link = reactive(useLink(props));\r\n        const { options } = inject(routerKey);\r\n        const elClass = computed(() => ({\r\n            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\r\n            // [getLinkClass(\r\n            //   props.inactiveClass,\r\n            //   options.linkInactiveClass,\r\n            //   'router-link-inactive'\r\n            // )]: !link.isExactActive,\r\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,\r\n        }));\r\n        return () => {\r\n            const children = slots.default && slots.default(link);\r\n            return props.custom\r\n                ? children\r\n                : h('a', assign({\r\n                    'aria-current': link.isExactActive ? 'page' : null,\r\n                    onClick: link.navigate,\r\n                    href: link.href,\r\n                }, attrs, {\r\n                    class: elClass.value,\r\n                }), children);\r\n        };\r\n    },\r\n});\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst RouterLink = RouterLinkImpl;\r\nfunction guardEvent(e) {\r\n    // don't redirect with control keys\r\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\r\n        return;\r\n    // don't redirect when preventDefault called\r\n    if (e.defaultPrevented)\r\n        return;\r\n    // don't redirect on right click\r\n    if (e.button !== undefined && e.button !== 0)\r\n        return;\r\n    // don't redirect if `target=\"_blank\"`\r\n    // @ts-ignore getAttribute does exist\r\n    if (e.currentTarget && e.currentTarget.getAttribute) {\r\n        // @ts-ignore getAttribute exists\r\n        const target = e.currentTarget.getAttribute('target');\r\n        if (/\\b_blank\\b/i.test(target))\r\n            return;\r\n    }\r\n    // this may be a Weex event which doesn't have this method\r\n    if (e.preventDefault)\r\n        e.preventDefault();\r\n    return true;\r\n}\r\nfunction includesParams(outer, inner) {\r\n    for (let key in inner) {\r\n        let innerValue = inner[key];\r\n        let outerValue = outer[key];\r\n        if (typeof innerValue === 'string') {\r\n            if (innerValue !== outerValue)\r\n                return false;\r\n        }\r\n        else {\r\n            if (!Array.isArray(outerValue) ||\r\n                outerValue.length !== innerValue.length ||\r\n                innerValue.some((value, i) => value !== outerValue[i]))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\r\nfunction getOriginalPath(record) {\r\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';\r\n}\r\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\r\nlet getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\r\n    ? propClass\r\n    : globalClass != null\r\n        ? globalClass\r\n        : defaultClass;\n\nconst RouterViewImpl = defineComponent({\r\n    name: 'RouterView',\r\n    props: {\r\n        name: {\r\n            type: String,\r\n            default: 'default',\r\n        },\r\n        route: Object,\r\n    },\r\n    setup(props, { attrs, slots }) {\r\n        (process.env.NODE_ENV !== 'production') && warnDeprecatedUsage();\r\n        const route = inject(routeLocationKey);\r\n        const depth = inject(viewDepthKey, 0);\r\n        const matchedRouteRef = computed(() => (props.route || route).matched[depth]);\r\n        provide(viewDepthKey, depth + 1);\r\n        provide(matchedRouteKey, matchedRouteRef);\r\n        const viewRef = ref();\r\n        return () => {\r\n            const matchedRoute = matchedRouteRef.value;\r\n            if (!matchedRoute) {\r\n                return null;\r\n            }\r\n            const ViewComponent = matchedRoute.components[props.name];\r\n            if (!ViewComponent) {\r\n                return null;\r\n            }\r\n            // props from route configration\r\n            const routePropsOption = matchedRoute.props[props.name];\r\n            const routeProps = routePropsOption\r\n                ? routePropsOption === true\r\n                    ? route.params\r\n                    : typeof routePropsOption === 'function'\r\n                        ? routePropsOption(route)\r\n                        : routePropsOption\r\n                : null;\r\n            // we need the value at the time we render because when we unmount, we\r\n            // navigated to a different location so the value is different\r\n            const currentName = props.name;\r\n            const onVnodeMounted = () => {\r\n                matchedRoute.instances[currentName] = viewRef.value;\r\n                (matchedRoute.enterCallbacks[currentName] || []).forEach(callback => callback(viewRef.value));\r\n            };\r\n            const onVnodeUnmounted = () => {\r\n                // remove the instance reference to prevent leak\r\n                matchedRoute.instances[currentName] = null;\r\n            };\r\n            const component = h(ViewComponent, assign({}, routeProps, attrs, {\r\n                onVnodeMounted,\r\n                onVnodeUnmounted,\r\n                ref: viewRef,\r\n            }));\r\n            return (\r\n            // pass the vnode to the slot as a prop.\r\n            // h and <component :is=\"...\"> both accept vnodes\r\n            slots.default\r\n                ? slots.default({ Component: component, route: matchedRoute })\r\n                : component);\r\n        };\r\n    },\r\n});\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst RouterView = RouterViewImpl;\r\n// warn against deprecated usage with <transition> & <keep-alive>\r\n// due to functional component being no longer eager in Vue 3\r\nfunction warnDeprecatedUsage() {\r\n    const instance = getCurrentInstance();\r\n    const parentName = instance.parent && instance.parent.type.name;\r\n    if (parentName &&\r\n        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\r\n        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\r\n        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` +\r\n            `Use slot props instead:\\n\\n` +\r\n            `<router-view v-slot=\"{ Component }\">\\n` +\r\n            `  <${comp}>\\n` +\r\n            `    <component :is=\"Component\" />\\n` +\r\n            `  </${comp}>\\n` +\r\n            `</router-view>`);\r\n    }\r\n}\n\n/**\r\n * Create a Router instance that can be used on a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\r\nfunction createRouter(options) {\r\n    const matcher = createRouterMatcher(options.routes, options);\r\n    let parseQuery$1 = options.parseQuery || parseQuery;\r\n    let stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\r\n    let { scrollBehavior } = options;\r\n    let routerHistory = options.history;\r\n    const beforeGuards = useCallbacks();\r\n    const beforeResolveGuards = useCallbacks();\r\n    const afterGuards = useCallbacks();\r\n    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\r\n    let pendingLocation = START_LOCATION_NORMALIZED;\r\n    // leave the scrollRestoration if no scrollBehavior is provided\r\n    if (isBrowser && scrollBehavior && 'scrollRestoration' in history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\r\n    const encodeParams = applyToParams.bind(null, encodeParam);\r\n    const decodeParams = applyToParams.bind(null, decode);\r\n    function addRoute(parentOrRoute, route) {\r\n        let parent;\r\n        let record;\r\n        if (isRouteName(parentOrRoute)) {\r\n            parent = matcher.getRecordMatcher(parentOrRoute);\r\n            record = route;\r\n        }\r\n        else {\r\n            record = parentOrRoute;\r\n        }\r\n        return matcher.addRoute(record, parent);\r\n    }\r\n    function removeRoute(name) {\r\n        let recordMatcher = matcher.getRecordMatcher(name);\r\n        if (recordMatcher) {\r\n            matcher.removeRoute(recordMatcher);\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Cannot remove non-existent route \"${String(name)}\"`);\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\r\n    }\r\n    function hasRoute(name) {\r\n        return !!matcher.getRecordMatcher(name);\r\n    }\r\n    function resolve(rawLocation, currentLocation) {\r\n        // const objectLocation = routerLocationAsObject(rawLocation)\r\n        currentLocation = currentLocation || currentRoute.value;\r\n        if (typeof rawLocation === 'string') {\r\n            let locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\r\n            let matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\r\n            let href = routerHistory.createHref(locationNormalized.fullPath);\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (href.startsWith('//'))\r\n                    warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n                else if (!matchedRoute.matched.length) {\r\n                    warn(`No match found for location with path \"${rawLocation}\"`);\r\n                }\r\n            }\r\n            // locationNormalized is always a new object\r\n            return assign(locationNormalized, matchedRoute, {\r\n                params: decodeParams(matchedRoute.params),\r\n                redirectedFrom: undefined,\r\n                href,\r\n            });\r\n        }\r\n        let matcherLocation;\r\n        // path could be relative in object as well\r\n        if ('path' in rawLocation) {\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                'params' in rawLocation &&\r\n                !('name' in rawLocation) &&\r\n                Object.keys(rawLocation.params).length) {\r\n                warn(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\r\n            }\r\n            matcherLocation = assign({}, rawLocation, {\r\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\r\n            });\r\n        }\r\n        else {\r\n            matcherLocation = assign({}, rawLocation, {\r\n                params: encodeParams(rawLocation.params),\r\n            });\r\n        }\r\n        let matchedRoute = matcher.resolve(matcherLocation, currentLocation);\r\n        const hash = encodeHash(rawLocation.hash || '');\r\n        if ((process.env.NODE_ENV !== 'production') && hash && !hash.startsWith('#')) {\r\n            warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\r\n        }\r\n        // put back the unencoded params as given by the user (avoid the cost of decoding them)\r\n        matchedRoute.params =\r\n            'params' in rawLocation\r\n                ? normalizeParams(rawLocation.params)\r\n                : decodeParams(matchedRoute.params);\r\n        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\r\n            hash,\r\n            path: matchedRoute.path,\r\n        }));\r\n        let href = routerHistory.createHref(fullPath);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (href.startsWith('//'))\r\n                warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n            else if (!matchedRoute.matched.length) {\r\n                warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\r\n            }\r\n        }\r\n        return assign({\r\n            fullPath,\r\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\r\n            // hash\r\n            hash,\r\n            query: \r\n            // if the user is using a custom query lib like qs, we might have\r\n            // nested objects, so we keep the query as is, meaning it can contain\r\n            // numbers at `$route.query`, but at the point, the user will have to\r\n            // use their own type anyway.\r\n            // https://github.com/vuejs/vue-router-next/issues/328#issuecomment-649481567\r\n            stringifyQuery$1 === stringifyQuery\r\n                ? normalizeQuery(rawLocation.query)\r\n                : rawLocation.query,\r\n        }, matchedRoute, {\r\n            redirectedFrom: undefined,\r\n            href,\r\n        });\r\n    }\r\n    function locationAsObject(to) {\r\n        return typeof to === 'string' ? { path: to } : assign({}, to);\r\n    }\r\n    function checkCanceledNavigation(to, from) {\r\n        if (pendingLocation !== to) {\r\n            return createRouterError(8 /* NAVIGATION_CANCELLED */, {\r\n                from,\r\n                to,\r\n            });\r\n        }\r\n    }\r\n    function push(to) {\r\n        return pushWithRedirect(to);\r\n    }\r\n    function replace(to) {\r\n        return push(assign(locationAsObject(to), { replace: true }));\r\n    }\r\n    function pushWithRedirect(to, redirectedFrom) {\r\n        const targetLocation = (pendingLocation = resolve(to));\r\n        const from = currentRoute.value;\r\n        const data = to.state;\r\n        const force = to.force;\r\n        // to could be a string where `replace` is a function\r\n        const replace = to.replace === true;\r\n        const lastMatched = targetLocation.matched[targetLocation.matched.length - 1];\r\n        if (lastMatched && lastMatched.redirect) {\r\n            const { redirect } = lastMatched;\r\n            // transform it into an object to pass the original RouteLocaleOptions\r\n            let newTargetLocation = locationAsObject(typeof redirect === 'function' ? redirect(targetLocation) : redirect);\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                !('path' in newTargetLocation) &&\r\n                !('name' in newTargetLocation)) {\r\n                warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${targetLocation.fullPath}\". A redirect must contain a name or path. This will break in production.`);\r\n                return Promise.reject(new Error('Invalid redirect'));\r\n            }\r\n            return pushWithRedirect(assign({}, \r\n            // having a path here would be a problem with relative locations but\r\n            // at the same time it doesn't make sense for a redirect to be\r\n            // relative (no name, no path) because it would create an infinite\r\n            // loop. Since newTargetLocation must either have a `path` or a\r\n            // `name`, this will never happen\r\n            targetLocation, newTargetLocation, {\r\n                state: data,\r\n                force,\r\n                replace,\r\n            }), \r\n            // keep original redirectedFrom if it exists\r\n            redirectedFrom || targetLocation);\r\n        }\r\n        // if it was a redirect we already called `pushWithRedirect` above\r\n        const toLocation = targetLocation;\r\n        toLocation.redirectedFrom = redirectedFrom;\r\n        let failure;\r\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\r\n            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });\r\n            // trigger scroll to allow scrolling to the same anchor\r\n            handleScroll(from, from, \r\n            // this is a push, the only way for it to be triggered from a\r\n            // history.listen is with a redirect, which makes it become a pus\r\n            true, \r\n            // This cannot be the first navigation because the initial location\r\n            // cannot be manually navigated to\r\n            false);\r\n        }\r\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\r\n            .catch((error) => {\r\n            if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ |\r\n                8 /* NAVIGATION_CANCELLED */ |\r\n                2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                return error;\r\n            }\r\n            // unknown error, rejects\r\n            return triggerError(error);\r\n        })\r\n            .then((failure) => {\r\n            if (failure) {\r\n                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */))\r\n                    // preserve the original redirectedFrom if any\r\n                    return pushWithRedirect(\r\n                    // keep options\r\n                    assign(locationAsObject(failure.to), {\r\n                        state: data,\r\n                        force,\r\n                        replace,\r\n                    }), redirectedFrom || toLocation);\r\n            }\r\n            else {\r\n                // if we fail we don't finalize the navigation\r\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\r\n            }\r\n            triggerAfterEach(toLocation, from, failure);\r\n            return failure;\r\n        });\r\n    }\r\n    /**\r\n     * Helper to reject and skip all navigation guards if a new navigation happened\r\n     * @param to\r\n     * @param from\r\n     */\r\n    function checkCanceledNavigationAndReject(to, from) {\r\n        const error = checkCanceledNavigation(to, from);\r\n        return error ? Promise.reject(error) : Promise.resolve();\r\n    }\r\n    // TODO: refactor the whole before guards by internally using router.beforeEach\r\n    function navigate(to, from) {\r\n        let guards;\r\n        // all components here have been resolved once because we are leaving\r\n        guards = extractComponentsGuards(from.matched.filter(record => to.matched.indexOf(record) < 0).reverse(), 'beforeRouteLeave', to, from);\r\n        const [leavingRecords, updatingRecords,] = extractChangingRecords(to, from);\r\n        for (const record of leavingRecords) {\r\n            for (const guard of record.leaveGuards) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n        }\r\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\r\n        guards.push(canceledNavigationCheck);\r\n        // run the queue of per route beforeRouteLeave guards\r\n        return (runGuardQueue(guards)\r\n            .then(() => {\r\n            // check global guards beforeEach\r\n            guards = [];\r\n            for (const guard of beforeGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check in components beforeRouteUpdate\r\n            guards = extractComponentsGuards(to.matched.filter(record => from.matched.indexOf(record) > -1), 'beforeRouteUpdate', to, from);\r\n            for (const record of updatingRecords) {\r\n                for (const guard of record.updateGuards) {\r\n                    guards.push(guardToPromiseFn(guard, to, from));\r\n                }\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check the route beforeEnter\r\n            guards = [];\r\n            for (const record of to.matched) {\r\n                // do not trigger beforeEnter on reused views\r\n                if (record.beforeEnter && from.matched.indexOf(record) < 0) {\r\n                    if (Array.isArray(record.beforeEnter)) {\r\n                        for (const beforeEnter of record.beforeEnter)\r\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\r\n                    }\r\n                    else {\r\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\r\n                    }\r\n                }\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\r\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\r\n            to.matched.forEach(record => (record.enterCallbacks = {}));\r\n            // check in-component beforeRouteEnter\r\n            guards = extractComponentsGuards(\r\n            // the type doesn't matter as we are comparing an object per reference\r\n            to.matched.filter(record => from.matched.indexOf(record) < 0), 'beforeRouteEnter', to, from);\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check global guards beforeResolve\r\n            guards = [];\r\n            for (const guard of beforeResolveGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            // catch any navigation canceled\r\n            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)\r\n            ? err\r\n            : Promise.reject(err)));\r\n    }\r\n    function triggerAfterEach(to, from, failure) {\r\n        // navigation is confirmed, call afterGuards\r\n        // TODO: wrap with error handlers\r\n        for (const guard of afterGuards.list())\r\n            guard(to, from, failure);\r\n    }\r\n    /**\r\n     * - Cleans up any navigation guards\r\n     * - Changes the url if necessary\r\n     * - Calls the scrollBehavior\r\n     */\r\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\r\n        // a more recent navigation took place\r\n        const error = checkCanceledNavigation(toLocation, from);\r\n        if (error)\r\n            return error;\r\n        const [leavingRecords] = extractChangingRecords(toLocation, from);\r\n        for (const record of leavingRecords) {\r\n            // remove registered guards from removed matched records\r\n            record.leaveGuards = [];\r\n            record.updateGuards = [];\r\n            // free the references\r\n            record.instances = {};\r\n            record.enterCallbacks = {};\r\n        }\r\n        // only consider as push if it's not the first navigation\r\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\r\n        const state = !isBrowser ? {} : history.state;\r\n        // change URL only if the user did a push/replace and if it's not the initial navigation because\r\n        // it's just reflecting the url\r\n        if (isPush) {\r\n            // on the initial navigation, we want to reuse the scroll position from\r\n            // history state if it exists\r\n            if (replace || isFirstNavigation)\r\n                routerHistory.replace(toLocation.fullPath, assign({\r\n                    scroll: isFirstNavigation && state && state.scroll,\r\n                }, data));\r\n            else\r\n                routerHistory.push(toLocation.fullPath, data);\r\n        }\r\n        // accept current navigation\r\n        currentRoute.value = toLocation;\r\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\r\n        markAsReady();\r\n    }\r\n    let removeHistoryListener;\r\n    // attach listener to history to trigger navigations\r\n    function setupListeners() {\r\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\r\n            // cannot be a redirect route because it was in history\r\n            const toLocation = resolve(to);\r\n            pendingLocation = toLocation;\r\n            const from = currentRoute.value;\r\n            // TODO: should be moved to web history?\r\n            if (isBrowser) {\r\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\r\n            }\r\n            navigate(toLocation, from)\r\n                .catch((error) => {\r\n                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\r\n                    return error;\r\n                }\r\n                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    // do not restore history on unknown direction\r\n                    if (info.delta)\r\n                        routerHistory.go(-info.delta, false);\r\n                    // the error is already handled by router.push we just want to avoid\r\n                    // logging the error\r\n                    pushWithRedirect(error.to, toLocation\r\n                    // avoid an uncaught rejection\r\n                    ).catch(noop);\r\n                    // avoid the then branch\r\n                    return Promise.reject();\r\n                }\r\n                // do not restore history on unknown direction\r\n                if (info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                // unrecognized error, transfer to the global handler\r\n                return triggerError(error);\r\n            })\r\n                .then((failure) => {\r\n                failure =\r\n                    failure ||\r\n                        finalizeNavigation(\r\n                        // after navigation, all matched components are resolved\r\n                        toLocation, from, false);\r\n                // revert the navigation\r\n                if (failure && info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                triggerAfterEach(toLocation, from, failure);\r\n            })\r\n                .catch(noop);\r\n        });\r\n    }\r\n    // Initialization and Errors\r\n    let readyHandlers = useCallbacks();\r\n    let errorHandlers = useCallbacks();\r\n    let ready;\r\n    /**\r\n     * Trigger errorHandlers added via onError and throws the error as well\r\n     * @param error - error to throw\r\n     * @returns the error as a rejected promise\r\n     */\r\n    function triggerError(error) {\r\n        markAsReady(error);\r\n        errorHandlers.list().forEach(handler => handler(error));\r\n        return Promise.reject(error);\r\n    }\r\n    /**\r\n     * Returns a Promise that resolves or reject when the router has finished its\r\n     * initial navigation. This will be automatic on client but requires an\r\n     * explicit `router.push` call on the server. This behavior can change\r\n     * depending on the history implementation used e.g. the defaults history\r\n     * implementation (client only) triggers this automatically but the memory one\r\n     * (should be used on server) doesn't\r\n     */\r\n    function isReady() {\r\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\r\n            return Promise.resolve();\r\n        return new Promise((resolve, reject) => {\r\n            readyHandlers.add([resolve, reject]);\r\n        });\r\n    }\r\n    /**\r\n     * Mark the router as ready, resolving the promised returned by isReady(). Can\r\n     * only be called once, otherwise does nothing.\r\n     * @param err - optional error\r\n     */\r\n    function markAsReady(err) {\r\n        if (ready)\r\n            return;\r\n        ready = true;\r\n        setupListeners();\r\n        readyHandlers\r\n            .list()\r\n            .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\r\n        readyHandlers.reset();\r\n    }\r\n    // Scroll behavior\r\n    function handleScroll(to, from, isPush, isFirstNavigation) {\r\n        if (!isBrowser || !scrollBehavior)\r\n            return Promise.resolve();\r\n        let scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\r\n            ((isFirstNavigation || !isPush) &&\r\n                history.state &&\r\n                history.state.scroll) ||\r\n            null;\r\n        return nextTick()\r\n            .then(() => scrollBehavior(to, from, scrollPosition))\r\n            .then(position => position && scrollToPosition(position))\r\n            .catch(triggerError);\r\n    }\r\n    function go(delta) {\r\n        return new Promise((resolve, reject) => {\r\n            let removeError = errorHandlers.add(err => {\r\n                removeError();\r\n                removeAfterEach();\r\n                reject(err);\r\n            });\r\n            let removeAfterEach = afterGuards.add((_to, _from, failure) => {\r\n                removeError();\r\n                removeAfterEach();\r\n                resolve(failure);\r\n            });\r\n            routerHistory.go(delta);\r\n        });\r\n    }\r\n    let started;\r\n    const installedApps = new Set();\r\n    const router = {\r\n        currentRoute,\r\n        addRoute,\r\n        removeRoute,\r\n        hasRoute,\r\n        getRoutes,\r\n        resolve,\r\n        options,\r\n        push,\r\n        replace,\r\n        go,\r\n        back: () => go(-1),\r\n        forward: () => go(1),\r\n        beforeEach: beforeGuards.add,\r\n        beforeResolve: beforeResolveGuards.add,\r\n        afterEach: afterGuards.add,\r\n        onError: errorHandlers.add,\r\n        isReady,\r\n        install(app) {\r\n            const router = this;\r\n            app.component('RouterLink', RouterLink);\r\n            app.component('RouterView', RouterView);\r\n            app.config.globalProperties.$router = router;\r\n            Object.defineProperty(app.config.globalProperties, '$route', {\r\n                get: () => unref(currentRoute),\r\n            });\r\n            // this initial navigation is only necessary on client, on server it doesn't\r\n            // make sense because it will create an extra unnecessary navigation and could\r\n            // lead to problems\r\n            if (isBrowser &&\r\n                // used for the initial navigation client side to avoid pushing\r\n                // multiple times when the router is used in multiple apps\r\n                !started &&\r\n                currentRoute.value === START_LOCATION_NORMALIZED) {\r\n                // see above\r\n                started = true;\r\n                push(routerHistory.location).catch(err => {\r\n                    if ((process.env.NODE_ENV !== 'production'))\r\n                        warn('Unexpected error when starting the router:', err);\r\n                });\r\n            }\r\n            const reactiveRoute = {};\r\n            for (let key in START_LOCATION_NORMALIZED) {\r\n                // @ts-ignore: the key matches\r\n                reactiveRoute[key] = computed(() => currentRoute.value[key]);\r\n            }\r\n            app.provide(routerKey, router);\r\n            app.provide(routeLocationKey, reactive(reactiveRoute));\r\n            let unmountApp = app.unmount;\r\n            installedApps.add(app);\r\n            app.unmount = function () {\r\n                installedApps.delete(app);\r\n                if (installedApps.size < 1) {\r\n                    removeHistoryListener();\r\n                    currentRoute.value = START_LOCATION_NORMALIZED;\r\n                    started = false;\r\n                    ready = false;\r\n                }\r\n                unmountApp.call(this, arguments);\r\n            };\r\n        },\r\n    };\r\n    return router;\r\n}\r\nfunction runGuardQueue(guards) {\r\n    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\r\n}\r\nfunction extractChangingRecords(to, from) {\r\n    const leavingRecords = [];\r\n    const updatingRecords = [];\r\n    const enteringRecords = [];\r\n    const len = Math.max(from.matched.length, to.matched.length);\r\n    for (let i = 0; i < len; i++) {\r\n        const recordFrom = from.matched[i];\r\n        if (recordFrom) {\r\n            if (to.matched.indexOf(recordFrom) < 0)\r\n                leavingRecords.push(recordFrom);\r\n            else\r\n                updatingRecords.push(recordFrom);\r\n        }\r\n        const recordTo = to.matched[i];\r\n        if (recordTo) {\r\n            // the type doesn't matter because we are comparing per reference\r\n            if (from.matched.indexOf(recordTo) < 0)\r\n                enteringRecords.push(recordTo);\r\n        }\r\n    }\r\n    return [leavingRecords, updatingRecords, enteringRecords];\r\n}\n\nfunction useRouter() {\r\n    return inject(routerKey);\r\n}\r\nfunction useRoute() {\r\n    return inject(routeLocationKey);\r\n}\n\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createWebHashHistory, createWebHistory, isNavigationFailure, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, stringifyQuery, useLink, useRoute, useRouter };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA,AAOA,IAAM,YAAY,OAAO,WAAW,cAAc,OAAO,OAAO,gBAAgB;AAChF,IAAM,aAAa,CAAC,SAEpB,YACM,OAAQ,OAAyC,mBAAmB,OAAO,QACzE,QAAyC,mBAAmB,UAAU;AAE9E,IAAM,kBAAkB,WAAY,OAAyC,iCAAiC;AAE9G,IAAM,eAAe,WAAY,OAAyC,sBAAsB;AAEhG,IAAM,YAAY,WAAY,OAAyC,WAAW;AAElF,IAAM,mBAAmB,WAAY,OAAyC,mBAAmB;AAEjG,IAAM,YAAY,OAAO,WAAW;AAEpC,oBAAoB,KAAK;AACrB,SAAO,IAAI,cAAe,aAAa,IAAI,OAAO,iBAAiB;AAAA;AAEvE,IAAM,SAAS,OAAO;AACtB,uBAAuB,IAAI,QAAQ;AAC/B,QAAM,YAAY;AAClB,aAAW,OAAO,QAAQ;AACtB,UAAM,QAAQ,OAAO;AACrB,cAAU,OAAO,MAAM,QAAQ,SAAS,MAAM,IAAI,MAAM,GAAG;AAAA;AAE/D,SAAO;AAAA;AAEX,IAAI,OAAO,MAAM;AAAA;AAEjB,IAAM,oBAAoB;AAC1B,IAAM,sBAAsB,CAAC,SAAS,KAAK,QAAQ,mBAAmB;AAUtE,kBAAkB,aAAY,WAAU,kBAAkB,KAAK;AAC3D,MAAI,MAAM,QAAQ,IAAI,eAAe,IAAI,OAAO;AAEhD,QAAM,YAAY,UAAS,QAAQ;AACnC,QAAM,UAAU,UAAS,QAAQ,KAAK,YAAY,KAAK,YAAY;AACnE,MAAI,YAAY,IAAI;AAChB,WAAO,UAAS,MAAM,GAAG;AACzB,mBAAe,UAAS,MAAM,YAAY,GAAG,UAAU,KAAK,UAAU,UAAS;AAC/E,YAAQ,YAAW;AAAA;AAEvB,MAAI,UAAU,IAAI;AACd,WAAO,QAAQ,UAAS,MAAM,GAAG;AAEjC,WAAO,UAAS,MAAM,SAAS,UAAS;AAAA;AAG5C,SAAO,QAAQ,OAAO,OAAO;AAE7B,MAAI,CAAC,MAAM;AACP,WAAO,kBAAkB;AAAA,aAEpB,KAAK,OAAO,KAAK;AAItB,WAAO,gBAAgB,QAAQ,WAAW,MAAM;AAAA;AAEpD,SAAO;AAAA,IACH,UAAU,OAAQ,iBAAgB,OAAO,eAAe;AAAA,IACxD;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AASR,sBAAsB,iBAAgB,WAAU;AAC5C,MAAI,QAAQ,UAAS,QAAQ,gBAAe,UAAS,SAAS;AAC9D,SAAO,UAAS,OAAQ,UAAS,OAAO,QAAS,WAAS,QAAQ;AAAA;AAStE,mBAAmB,UAAU,MAAM;AAE/B,MAAI,CAAC,QAAQ,SAAS,cAAc,QAAQ,KAAK;AAC7C,WAAO;AACX,SAAO,SAAS,MAAM,KAAK,WAAW;AAAA;AAU1C,6BAA6B,iBAAgB,GAAG,GAAG;AAC/C,MAAI,aAAa,EAAE,QAAQ,SAAS;AACpC,MAAI,aAAa,EAAE,QAAQ,SAAS;AACpC,SAAQ,aAAa,MACjB,eAAe,cACf,kBAAkB,EAAE,QAAQ,aAAa,EAAE,QAAQ,gBACnD,0BAA0B,EAAE,QAAQ,EAAE,WACtC,gBAAe,EAAE,WAAW,gBAAe,EAAE,UAC7C,EAAE,SAAS,EAAE;AAAA;AASrB,2BAA2B,GAAG,GAAG;AAI7B,SAAQ,GAAE,WAAW,OAAQ,GAAE,WAAW;AAAA;AAE9C,mCAAmC,GAAG,GAAG;AACrC,MAAI,OAAO,KAAK,GAAG,WAAW,OAAO,KAAK,GAAG;AACzC,WAAO;AACX,WAAS,OAAO,GAAG;AACf,QAAI,CAAC,+BAA+B,EAAE,MAAM,EAAE;AAC1C,aAAO;AAAA;AAEf,SAAO;AAAA;AAEX,wCAAwC,GAAG,GAAG;AAC1C,SAAO,MAAM,QAAQ,KACf,kBAAkB,GAAG,KACrB,MAAM,QAAQ,KACV,kBAAkB,GAAG,KACrB,MAAM;AAAA;AASpB,2BAA2B,GAAG,GAAG;AAC7B,SAAO,MAAM,QAAQ,KACf,EAAE,WAAW,EAAE,UAAU,EAAE,MAAM,CAAC,OAAO,MAAM,UAAU,EAAE,MAC3D,EAAE,WAAW,KAAK,EAAE,OAAO;AAAA;AAGrC,IAAI;AACJ,AAAC,UAAU,iBAAgB;AACvB,kBAAe,SAAS;AACxB,kBAAe,UAAU;AAAA,GAC1B,kBAAmB,kBAAiB;AACvC,IAAI;AACJ,AAAC,UAAU,sBAAqB;AAC5B,uBAAoB,UAAU;AAC9B,uBAAoB,aAAa;AACjC,uBAAoB,aAAa;AAAA,GAClC,uBAAwB,uBAAsB;AAIjD,IAAM,QAAQ;AAQd,uBAAuB,MAAM;AACzB,MAAI,CAAC,MAAM;AACP,QAAI,WAAW;AAEX,YAAM,SAAS,SAAS,cAAc;AACtC,aAAQ,UAAU,OAAO,aAAa,WAAY;AAElD,aAAO,KAAK,QAAQ,mBAAmB;AAAA,WAEtC;AACD,aAAO;AAAA;AAAA;AAMf,MAAI,KAAK,OAAO,OAAO,KAAK,OAAO;AAC/B,WAAO,MAAM;AAGjB,SAAO,oBAAoB;AAAA;AAG/B,IAAM,iBAAiB;AACvB,oBAAoB,MAAM,WAAU;AAChC,SAAO,KAAK,QAAQ,gBAAgB,OAAO;AAAA;AAG/C,eAAc,QAAQ,MAAM;AACxB,UAAQ,KAAK,wBAAwB,KAAK,GAAG;AAAA;AAGjD,4BAA4B,IAAI,QAAQ;AACpC,QAAM,UAAU,SAAS,gBAAgB;AACzC,QAAM,SAAS,GAAG;AAClB,SAAO;AAAA,IACH,UAAU,OAAO;AAAA,IACjB,MAAM,OAAO,OAAO,QAAQ,OAAQ,QAAO,QAAQ;AAAA,IACnD,KAAK,OAAO,MAAM,QAAQ,MAAO,QAAO,OAAO;AAAA;AAAA;AAGvD,IAAM,wBAAwB,MAAO;AAAA,EACjC,MAAM,OAAO;AAAA,EACb,KAAK,OAAO;AAAA;AAEhB,0BAA0B,UAAU;AAChC,MAAI;AACJ,MAAI,QAAQ,UAAU;AAClB,QAAI,aAAa,SAAS;AAC1B,UAAM,eAAe,OAAO,eAAe,YAAY,WAAW,WAAW;AAsB7E,QAA+C,OAAO,SAAS,OAAO,UAAU;AAC5E,UAAI,CAAC,gBAAgB,CAAC,SAAS,eAAe,SAAS,GAAG,MAAM,KAAK;AACjE,YAAI;AACA,cAAI,UAAU,SAAS,cAAc,SAAS;AAC9C,cAAI,gBAAgB,SAAS;AACzB,kBAAK,iBAAiB,SAAS,wDAAwD,SAAS;AAEhG;AAAA;AAAA,gBAGR;AACI,gBAAK,iBAAiB,SAAS;AAE/B;AAAA;AAAA;AAAA;AAIZ,UAAM,KAAK,OAAO,eAAe,WAC3B,eACI,SAAS,eAAe,WAAW,MAAM,MACzC,SAAS,cAAc,cAC3B;AACN,QAAI,CAAC,IAAI;AACL,MAA2C,MAAK,yCAAyC,SAAS;AAClG;AAAA;AAEJ,sBAAkB,mBAAmB,IAAI;AAAA,SAExC;AACD,sBAAkB;AAAA;AAEtB,MAAI,oBAAoB,SAAS,gBAAgB;AAC7C,WAAO,SAAS;AAAA,OACf;AACD,WAAO,SAAS,gBAAgB,QAAQ,OAAO,gBAAgB,OAAO,OAAO,aAAa,gBAAgB,OAAO,OAAO,gBAAgB,MAAM,OAAO;AAAA;AAAA;AAG7J,sBAAsB,MAAM,OAAO;AAC/B,QAAM,WAAW,QAAQ,QAAQ,QAAQ,MAAM,WAAW,QAAQ;AAClE,SAAO,WAAW;AAAA;AAEtB,IAAM,kBAAkB,IAAI;AAC5B,4BAA4B,KAAK,gBAAgB;AAC7C,kBAAgB,IAAI,KAAK;AAAA;AAE7B,gCAAgC,KAAK;AACjC,QAAM,SAAS,gBAAgB,IAAI;AAEnC,kBAAgB,OAAO;AACvB,SAAO;AAAA;AAkBX,IAAI,qBAAqB,MAAM,SAAS,WAAW,OAAO,SAAS;AAKnE,+BAA+B,MAAM,WAAU;AAC3C,QAAM,EAAE,UAAU,QAAQ,SAAS;AAEnC,QAAM,UAAU,KAAK,QAAQ;AAC7B,MAAI,UAAU,IAAI;AAEd,QAAI,eAAe,KAAK,MAAM;AAC9B,QAAI,aAAa,OAAO;AACpB,qBAAe,MAAM;AACzB,WAAO,UAAU,cAAc;AAAA;AAEnC,QAAM,OAAO,UAAU,UAAU;AACjC,SAAO,OAAO,SAAS;AAAA;AAE3B,6BAA6B,MAAM,cAAc,iBAAiB,SAAS;AACvE,MAAI,YAAY;AAChB,MAAI,YAAY;AAGhB,MAAI,aAAa;AACjB,QAAM,kBAAkB,CAAC,EAAE,YAAa;AACpC,UAAM,KAAK,sBAAsB,MAAM;AACvC,UAAM,OAAO,gBAAgB;AAC7B,UAAM,YAAY,aAAa;AAC/B,QAAI,QAAQ;AACZ,QAAI,OAAO;AACP,sBAAgB,QAAQ;AACxB,mBAAa,QAAQ;AAErB,UAAI,cAAc,eAAe,MAAM;AACnC,qBAAa;AACb;AAAA;AAEJ,cAAQ,YAAY,MAAM,WAAW,UAAU,WAAW;AAAA,WAEzD;AACD,cAAQ;AAAA;AAQZ,cAAU,QAAQ,cAAY;AAC1B,eAAS,gBAAgB,OAAO,MAAM;AAAA,QAClC;AAAA,QACA,MAAM,eAAe;AAAA,QACrB,WAAW,QACL,QAAQ,IACJ,oBAAoB,UACpB,oBAAoB,OACxB,oBAAoB;AAAA;AAAA;AAAA;AAItC,4BAA0B;AACtB,iBAAa,gBAAgB;AAAA;AAEjC,kBAAgB,UAAU;AAEtB,cAAU,KAAK;AACf,UAAM,WAAW,MAAM;AACnB,YAAM,QAAQ,UAAU,QAAQ;AAChC,UAAI,QAAQ;AACR,kBAAU,OAAO,OAAO;AAAA;AAEhC,cAAU,KAAK;AACf,WAAO;AAAA;AAEX,kCAAgC;AAC5B,UAAM,EAAE,sBAAY;AACpB,QAAI,CAAC,SAAQ;AACT;AACJ,aAAQ,aAAa,OAAO,IAAI,SAAQ,OAAO,EAAE,QAAQ,4BAA4B;AAAA;AAEzF,qBAAmB;AACf,eAAW,YAAY;AACnB;AACJ,gBAAY;AACZ,WAAO,oBAAoB,YAAY;AACvC,WAAO,oBAAoB,gBAAgB;AAAA;AAG/C,SAAO,iBAAiB,YAAY;AACpC,SAAO,iBAAiB,gBAAgB;AACxC,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAMR,oBAAoB,MAAM,SAAS,SAAS,WAAW,OAAO,gBAAgB,OAAO;AACjF,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,OAAO,QAAQ;AAAA,IACzB,QAAQ,gBAAgB,0BAA0B;AAAA;AAAA;AAG1D,mCAAmC,MAAM;AACrC,QAAM,EAAE,mBAAS,wBAAa;AAE9B,MAAI,kBAAkB;AAAA,IAClB,OAAO,sBAAsB,MAAM;AAAA;AAEvC,MAAI,eAAe,EAAE,OAAO,SAAQ;AAEpC,MAAI,CAAC,aAAa,OAAO;AACrB,mBAAe,gBAAgB,OAAO;AAAA,MAClC,MAAM;AAAA,MACN,SAAS,gBAAgB;AAAA,MACzB,SAAS;AAAA,MAET,UAAU,SAAQ,SAAS;AAAA,MAC3B,UAAU;AAAA,MAGV,QAAQ;AAAA,OACT;AAAA;AAEP,0BAAwB,IAAI,OAAO,UAAS;AACxC,UAAM,MAAM,uBAEP,MAAK,QAAQ,OAAO,MAAM,UAAS,SAC9B,UAAS,WAAW,UAAS,SAAS,MACtC,QACN;AACJ,QAAI;AAGA,eAAQ,WAAU,iBAAiB,aAAa,OAAO,IAAI;AAC3D,mBAAa,QAAQ;AAAA,aAElB,KAAP;AACI,YAAK,iCAAiC;AAEtC,gBAAS,WAAU,YAAY,UAAU;AAAA;AAAA;AAGjD,mBAAiB,IAAI,MAAM;AACvB,UAAM,QAAQ,OAAO,IAAI,SAAQ,OAAO,WAAW,aAAa,MAAM,MAEtE,IAAI,aAAa,MAAM,SAAS,OAAO,MAAM,EAAE,UAAU,aAAa,MAAM;AAC5E,mBAAe,IAAI,OAAO;AAC1B,oBAAgB,QAAQ;AAAA;AAE5B,gBAAc,IAAI,MAAM;AAGpB,UAAM,eAAe,OAAO,IAAI,SAAQ,OAAO;AAAA,MAC3C,SAAS;AAAA,MACT,QAAQ;AAAA;AAEZ,mBAAe,aAAa,SAAS,cAAc;AACnD,UAAM,QAAQ,OAAO,IAAI,WAAW,gBAAgB,OAAO,IAAI,OAAO;AAAA,MAClE,UAAU,aAAa,WAAW;AAAA,OACnC;AACH,mBAAe,IAAI,OAAO;AAC1B,oBAAgB,QAAQ;AAAA;AAE5B,SAAO;AAAA,IACH,UAAU;AAAA,IACV,OAAO;AAAA,IACP;AAAA,IACA;AAAA;AAAA;AAGR,0BAA0B,MAAM;AAC5B,SAAO,cAAc;AACrB,QAAM,oBAAoB,0BAA0B;AACpD,QAAM,mBAAmB,oBAAoB,MAAM,kBAAkB,OAAO,kBAAkB,UAAU,kBAAkB;AAC1H,cAAY,OAAO,mBAAmB,MAAM;AACxC,QAAI,CAAC;AACD,uBAAiB;AACrB,YAAQ,GAAG;AAAA;AAEf,QAAM,gBAAgB,OAAO;AAAA,IAEzB,UAAU;AAAA,IACV;AAAA,IACA;AAAA,IACA,YAAY,WAAW,KAAK,MAAM;AAAA,KACnC,mBAAmB;AACtB,SAAO,eAAe,eAAe,YAAY;AAAA,IAC7C,KAAK,MAAM,kBAAkB,SAAS;AAAA;AAE1C,SAAO,eAAe,eAAe,SAAS;AAAA,IAC1C,KAAK,MAAM,kBAAkB,MAAM;AAAA;AAEvC,SAAO;AAAA;AAUX,6BAA6B,OAAO,IAAI;AACpC,MAAI,YAAY;AAChB,MAAI,QAAQ,CAAC;AACb,MAAI,WAAW;AACf,uBAAqB,WAAU;AAC3B;AACA,QAAI,aAAa,MAAM,QAAQ;AAE3B,YAAM,KAAK;AAAA,WAEV;AAED,YAAM,OAAO;AACb,YAAM,KAAK;AAAA;AAAA;AAGnB,4BAA0B,IAAI,MAAM,EAAE,WAAW,SAAS;AACtD,UAAM,OAAO;AAAA,MACT;AAAA,MACA;AAAA,MACA,MAAM,eAAe;AAAA;AAEzB,aAAS,YAAY,WAAW;AAC5B,eAAS,IAAI,MAAM;AAAA;AAAA;AAG3B,QAAM,gBAAgB;AAAA,IAElB,UAAU;AAAA,IACV,OAAO;AAAA,IACP;AAAA,IACA,YAAY,WAAW,KAAK,MAAM;AAAA,IAClC,QAAQ,IAAI;AAER,YAAM,OAAO,YAAY;AACzB,kBAAY;AAAA;AAAA,IAEhB,KAAK,IAAI,MAAM;AACX,kBAAY;AAAA;AAAA,IAEhB,OAAO,UAAU;AACb,gBAAU,KAAK;AACf,aAAO,MAAM;AACT,cAAM,QAAQ,UAAU,QAAQ;AAChC,YAAI,QAAQ;AACR,oBAAU,OAAO,OAAO;AAAA;AAAA;AAAA,IAGpC,UAAU;AACN,kBAAY;AAAA;AAAA,IAEhB,GAAG,OAAO,gBAAgB,MAAM;AAC5B,YAAM,OAAO,KAAK;AAClB,YAAM,YAIN,QAAQ,IAAI,oBAAoB,OAAO,oBAAoB;AAC3D,iBAAW,KAAK,IAAI,GAAG,KAAK,IAAI,WAAW,OAAO,MAAM,SAAS;AACjE,UAAI,eAAe;AACf,yBAAiB,KAAK,UAAU,MAAM;AAAA,UAClC;AAAA,UACA;AAAA;AAAA;AAAA;AAAA;AAKhB,SAAO,eAAe,eAAe,YAAY;AAAA,IAC7C,KAAK,MAAM,MAAM;AAAA;AAErB,SAAO;AAAA;AAyBX,8BAA8B,MAAM;AAIhC,SAAO,SAAS,OAAO,QAAQ,SAAS,WAAW,SAAS;AAE5D,MAAI,KAAK,QAAQ,OAAO;AACpB,YAAQ;AACZ,MAAK,AAA0C,CAAC,KAAK,SAAS,SAAS,CAAC,KAAK,SAAS,MAAM;AACxF,UAAK;AAAA,GAAsC,oBAAoB,KAAK,QAAQ,QAAQ;AAAA;AAExF,SAAO,iBAAiB;AAAA;AAoB5B,IAAM,UAAU;AAChB,IAAM,eAAe;AACrB,IAAM,WAAW;AACjB,IAAM,WAAW;AACjB,IAAM,QAAQ;AACd,IAAM,sBAAsB;AAC5B,IAAM,uBAAuB;AAC7B,IAAM,eAAe;AACrB,IAAM,kBAAkB;AACxB,IAAM,oBAAoB;AAC1B,IAAM,cAAc;AACpB,IAAM,qBAAqB;AAS3B,sBAAsB,MAAM;AACxB,SAAO,UAAU,KAAK,MACjB,QAAQ,aAAa,KACrB,QAAQ,qBAAqB,KAC7B,QAAQ,sBAAsB;AAAA;AAQvC,oBAAoB,MAAM;AACtB,SAAO,aAAa,MACf,QAAQ,mBAAmB,KAC3B,QAAQ,oBAAoB,KAC5B,QAAQ,cAAc;AAAA;AAS/B,6BAA6B,MAAM;AAC/B,SAAO,aAAa,MACf,QAAQ,SAAS,OACjB,QAAQ,cAAc,OACtB,QAAQ,UAAU,OAClB,QAAQ,iBAAiB,KACzB,QAAQ,mBAAmB,KAC3B,QAAQ,oBAAoB,KAC5B,QAAQ,cAAc;AAAA;AAQ/B,oBAAoB,MAAM;AACtB,SAAO,aAAa,MAAM,QAAQ,SAAS,OAAO,QAAQ,OAAO;AAAA;AAUrE,qBAAqB,MAAM;AACvB,SAAO,WAAW,MAAM,QAAQ,UAAU;AAAA;AAS9C,gBAAgB,MAAM;AAClB,MAAI;AACA,WAAO,mBAAmB,KAAK;AAAA,WAE5B,KAAP;AACI,IAA2C,MAAK,mBAAmB;AAAA;AAEvE,SAAO,KAAK;AAAA;AAUhB,oBAAoB,QAAQ;AACxB,QAAM,QAAQ;AAGd,MAAI,WAAW,MAAM,WAAW;AAC5B,WAAO;AACX,QAAM,eAAe,OAAO,OAAO;AACnC,QAAM,eAAgB,gBAAe,OAAO,MAAM,KAAK,QAAQ,MAAM;AACrE,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,EAAE,GAAG;AAC1C,QAAI,CAAC,KAAK,YAAY,aAAa,GAAG,MAAM;AAC5C,UAAM,OAAO;AAEb,QAAI,QAAQ,YAAY,OAAO,OAAO,OAAO;AAC7C,QAAI,OAAO,OAAO;AAEd,UAAI,eAAe,MAAM;AACzB,UAAI,CAAC,MAAM,QAAQ,eAAe;AAC9B,uBAAe,MAAM,OAAO,CAAC;AAAA;AAEjC,mBAAa,KAAK;AAAA,WAEjB;AACD,YAAM,OAAO;AAAA;AAAA;AAGrB,SAAO;AAAA;AASX,wBAAwB,OAAO;AAC3B,MAAI,SAAS;AACb,WAAS,OAAO,OAAO;AACnB,QAAI,OAAO;AACP,gBAAU;AACd,UAAM,QAAQ,MAAM;AACpB,UAAM,oBAAoB;AAC1B,QAAI,SAAS,MAAM;AAEf,UAAI,UAAU;AACV,kBAAU;AACd;AAAA;AAGJ,QAAI,SAAS,MAAM,QAAQ,SACrB,MAAM,IAAI,OAAK,KAAK,oBAAoB,MACxC,CAAC,SAAS,oBAAoB;AACpC,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AAEpC,gBAAW,KAAI,MAAM,MAAM;AAC3B,UAAI,OAAO,MAAM;AACb,kBAAW,MAAM,OAAO;AAAA;AAAA;AAGpC,SAAO;AAAA;AAUX,wBAAwB,OAAO;AAC3B,QAAM,kBAAkB;AACxB,WAAS,OAAO,OAAO;AACnB,QAAI,QAAQ,MAAM;AAClB,QAAI,UAAU,QAAW;AACrB,sBAAgB,OAAO,MAAM,QAAQ,SAC/B,MAAM,IAAI,OAAM,KAAK,OAAO,OAAO,KAAK,KACxC,SAAS,OACL,QACA,KAAK;AAAA;AAAA;AAGvB,SAAO;AAAA;AAGX,yBAAyB,OAAO;AAC5B,SAAO,OAAO,UAAU,YAAa,SAAS,OAAO,UAAU;AAAA;AAEnE,qBAAqB,MAAM;AACvB,SAAO,OAAO,SAAS,YAAY,OAAO,SAAS;AAAA;AAGvD,IAAM,4BAA4B;AAAA,EAC9B,MAAM;AAAA,EACN,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,UAAU;AAAA,EACV,SAAS;AAAA,EACT,MAAM;AAAA,EACN,gBAAgB;AAAA;AAGpB,IAAM,0BAA0B,WAAY,OAAyC,uBAAuB;AAC5G,IAAI;AACJ,AAAC,UAAU,wBAAuB;AAC9B,yBAAsB,uBAAsB,aAAa,KAAK;AAC9D,yBAAsB,uBAAsB,eAAe,KAAK;AAChE,yBAAsB,uBAAsB,gBAAgB,MAAM;AAAA,GACnE,yBAA0B,yBAAwB;AAErD,IAAM,oBAAoB;AAAA,GACrB,GAA2B,EAAE,qBAAU,mBAAmB;AACvD,WAAO;AAAA,GAAkB,KAAK,UAAU,aAAY,kBAC9C,uBAAuB,KAAK,UAAU,mBACtC;AAAA;AAAA,GAET,GAAmC,EAAE,MAAM,MAAO;AAC/C,WAAO,oBAAoB,KAAK,iBAAiB,eAAe;AAAA;AAAA,GAEnE,GAA4B,EAAE,MAAM,MAAM;AACvC,WAAO,4BAA4B,KAAK,iBAAiB,GAAG;AAAA;AAAA,GAE/D,GAA8B,EAAE,MAAM,MAAM;AACzC,WAAO,8BAA8B,KAAK,iBAAiB,GAAG;AAAA;AAAA,GAEjE,IAAgC,EAAE,MAAM,MAAM;AAC3C,WAAO,sDAAsD,KAAK;AAAA;AAAA;AAG1E,2BAA2B,MAAM,QAAQ;AACrC,MAAK,MAAiD;AAClD,WAAO,OAAO,IAAI,MAAM,kBAAkB,MAAM,UAAU;AAAA,MACtD;AAAA,OACC,0BAA0B;AAAA,OAC5B;AAAA,SAEF;AACD,WAAO,OAAO,IAAI,SAAS;AAAA,MACvB;AAAA,OACC,0BAA0B;AAAA,OAC5B;AAAA;AAAA;AAGX,6BAA6B,OAAO,MAAM;AACtC,SAAQ,iBAAiB,SACrB,2BAA2B,SAC1B,SAAQ,QAAQ,CAAC,CAAE,OAAM,OAAO;AAAA;AAEzC,IAAM,kBAAkB,CAAC,UAAU,SAAS;AAC5C,wBAAwB,IAAI;AACxB,MAAI,OAAO,OAAO;AACd,WAAO;AACX,MAAI,UAAU;AACV,WAAO,GAAG;AACd,QAAM,YAAW;AACjB,aAAW,OAAO,iBAAiB;AAC/B,QAAI,OAAO;AACP,gBAAS,OAAO,GAAG;AAAA;AAE3B,SAAO,KAAK,UAAU,WAAU,MAAM;AAAA;AAI1C,IAAM,qBAAqB;AAC3B,IAAM,2BAA2B;AAAA,EAC7B,WAAW;AAAA,EACX,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,KAAK;AAAA;AAGT,IAAM,iBAAiB;AAQvB,wBAAwB,UAAU,cAAc;AAC5C,QAAM,UAAU,OAAO,IAAI,0BAA0B;AAErD,MAAI,QAAQ;AAEZ,MAAI,UAAU,QAAQ,QAAQ,MAAM;AAEpC,QAAM,OAAO;AACb,aAAW,WAAW,UAAU;AAE5B,UAAM,gBAAgB,QAAQ,SAAS,KAAK,CAAC;AAE7C,QAAI,QAAQ,UAAU,CAAC,QAAQ;AAC3B,iBAAW;AACf,aAAS,aAAa,GAAG,aAAa,QAAQ,QAAQ,cAAc;AAChE,YAAM,QAAQ,QAAQ;AAEtB,UAAI,kBAAkB,KACjB,SAAQ,YAAY,OAAgC;AACzD,UAAI,MAAM,SAAS,GAAgB;AAE/B,YAAI,CAAC;AACD,qBAAW;AACf,mBAAW,MAAM,MAAM,QAAQ,gBAAgB;AAC/C,2BAAmB;AAAA,iBAEd,MAAM,SAAS,GAAe;AACnC,cAAM,EAAE,OAAO,YAAY,UAAU,WAAW;AAChD,aAAK,KAAK;AAAA,UACN,MAAM;AAAA,UACN;AAAA,UACA;AAAA;AAEJ,cAAM,MAAK,SAAS,SAAS;AAE7B,YAAI,QAAO,oBAAoB;AAC3B,6BAAmB;AAEnB,cAAI;AACA,gBAAI,OAAO,IAAI;AAAA,mBAEZ,KAAP;AACI,kBAAM,IAAI,MAAM,oCAAoC,WAAW,WAC3D,IAAI;AAAA;AAAA;AAIhB,YAAI,aAAa,aAAa,OAAO,cAAa,YAAW,IAAI;AAEjE,YAAI,CAAC;AACD,uBAAa,WAAW,OAAO,gBAAgB,MAAM;AACzD,YAAI;AACA,wBAAc;AAClB,mBAAW;AACX,2BAAmB;AACnB,YAAI;AACA,6BAAmB;AACvB,YAAI;AACA,6BAAmB;AACvB,YAAI,QAAO;AACP,6BAAmB;AAAA;AAE3B,oBAAc,KAAK;AAAA;AAIvB,UAAM,KAAK;AAAA;AAGf,MAAI,QAAQ,UAAU,QAAQ,KAAK;AAC/B,UAAM,IAAI,MAAM,SAAS;AACzB,UAAM,GAAG,MAAM,GAAG,SAAS,MAAM;AAAA;AAGrC,MAAI,CAAC,QAAQ;AACT,eAAW;AACf,MAAI,QAAQ;AACR,eAAW;AAAA,WAEN,QAAQ;AACb,eAAW;AACf,QAAM,KAAK,IAAI,OAAO,SAAS,QAAQ,YAAY,KAAK;AACxD,iBAAe,MAAM;AACjB,UAAM,QAAQ,KAAK,MAAM;AACzB,UAAM,SAAS;AACf,QAAI,CAAC;AACD,aAAO;AACX,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,YAAM,QAAQ,MAAM,MAAM;AAC1B,YAAM,MAAM,KAAK,IAAI;AACrB,aAAO,IAAI,QAAQ,SAAS,IAAI,aAAa,MAAM,MAAM,OAAO;AAAA;AAEpE,WAAO;AAAA;AAEX,qBAAmB,QAAQ;AACvB,QAAI,OAAO;AAEX,QAAI,uBAAuB;AAC3B,eAAW,WAAW,UAAU;AAC5B,UAAI,CAAC,wBAAwB,KAAK,KAAK,SAAS,OAAO;AACnD,gBAAQ;AACZ,6BAAuB;AACvB,iBAAW,SAAS,SAAS;AACzB,YAAI,MAAM,SAAS,GAAgB;AAC/B,kBAAQ,MAAM;AAAA,mBAET,MAAM,SAAS,GAAe;AACnC,gBAAM,EAAE,OAAO,YAAY,aAAa;AACxC,gBAAM,QAAQ,SAAS,SAAS,OAAO,SAAS;AAChD,cAAI,MAAM,QAAQ,UAAU,CAAC;AACzB,kBAAM,IAAI,MAAM,mBAAmB;AACvC,gBAAM,OAAO,MAAM,QAAQ,SAAS,MAAM,KAAK,OAAO;AACtD,cAAI,CAAC,MAAM;AAEP,gBAAI;AACA,qCAAuB;AAAA;AAEvB,oBAAM,IAAI,MAAM,2BAA2B;AAAA;AAEnD,kBAAQ;AAAA;AAAA;AAAA;AAIpB,WAAO;AAAA;AAEX,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAWR,2BAA2B,GAAG,GAAG;AAC7B,MAAI,IAAI;AACR,SAAO,IAAI,EAAE,UAAU,IAAI,EAAE,QAAQ;AACjC,UAAM,OAAO,EAAE,KAAK,EAAE;AAEtB,QAAI;AACA,aAAO;AACX;AAAA;AAIJ,MAAI,EAAE,SAAS,EAAE,QAAQ;AACrB,WAAO,EAAE,WAAW,KAAK,EAAE,OAAO,KAAkB,KAC9C,KACA;AAAA,aAED,EAAE,SAAS,EAAE,QAAQ;AAC1B,WAAO,EAAE,WAAW,KAAK,EAAE,OAAO,KAAkB,KAC9C,IACA;AAAA;AAEV,SAAO;AAAA;AAQX,gCAAgC,GAAG,GAAG;AAClC,MAAI,IAAI;AACR,QAAM,SAAS,EAAE;AACjB,QAAM,SAAS,EAAE;AACjB,SAAO,IAAI,OAAO,UAAU,IAAI,OAAO,QAAQ;AAC3C,UAAM,OAAO,kBAAkB,OAAO,IAAI,OAAO;AAEjD,QAAI;AACA,aAAO;AACX;AAAA;AAGJ,SAAO,OAAO,SAAS,OAAO;AAAA;AASlC,IAAM,aAAa;AAAA,EACf,MAAM;AAAA,EACN,OAAO;AAAA;AAEX,IAAM,iBAAiB;AAIvB,sBAAsB,MAAM;AACxB,MAAI,CAAC;AACD,WAAO,CAAC;AACZ,MAAI,SAAS;AACT,WAAO,CAAC,CAAC;AAEb,MAAI,KAAK,OAAO;AACZ,UAAM,IAAI,MAAM;AAEpB,iBAAe,SAAS;AACpB,UAAM,IAAI,MAAM,QAAQ,WAAW,YAAY;AAAA;AAEnD,MAAI,QAAQ;AACZ,MAAI,gBAAgB;AACpB,QAAM,SAAS;AAGf,MAAI;AACJ,6BAA2B;AACvB,QAAI;AACA,aAAO,KAAK;AAChB,cAAU;AAAA;AAGd,MAAI,IAAI;AAER,MAAI;AAEJ,MAAI,SAAS;AAEb,MAAI,WAAW;AACf,2BAAyB;AACrB,QAAI,CAAC;AACD;AACJ,QAAI,UAAU,GAAgB;AAC1B,cAAQ,KAAK;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA;AAAA,eAGN,UAAU,KACf,UAAU,KACV,UAAU,GAAwB;AAClC,UAAI,QAAQ,SAAS,KAAM,UAAS,OAAO,SAAS;AAChD,cAAM,uBAAuB;AACjC,cAAQ,KAAK;AAAA,QACT,MAAM;AAAA,QACN,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,YAAY,SAAS,OAAO,SAAS;AAAA,QACrC,UAAU,SAAS,OAAO,SAAS;AAAA;AAAA,WAGtC;AACD,YAAM;AAAA;AAEV,aAAS;AAAA;AAEb,6BAA2B;AACvB,cAAU;AAAA;AAEd,SAAO,IAAI,KAAK,QAAQ;AACpB,WAAO,KAAK;AACZ,QAAI,SAAS,QAAQ,UAAU,GAAqB;AAChD,sBAAgB;AAChB,cAAQ;AACR;AAAA;AAEJ,YAAQ;AAAA,WACC;AACD,YAAI,SAAS,KAAK;AACd,cAAI,QAAQ;AACR;AAAA;AAEJ;AAAA,mBAEK,SAAS,KAAK;AACnB;AACA,kBAAQ;AAAA,eAEP;AACD;AAAA;AAEJ;AAAA,WACC;AACD;AACA,gBAAQ;AACR;AAAA,WACC;AACD,YAAI,SAAS,KAAK;AACd,kBAAQ;AACR,qBAAW;AAAA,mBAEN,eAAe,KAAK,OAAO;AAChC;AAAA,eAEC;AACD;AACA,kBAAQ;AAER,cAAI,SAAS,OAAO,SAAS,OAAO,SAAS;AACzC;AAAA;AAER;AAAA,WACC;AACD,YAAI,SAAS,KAAK;AAEd,cAAI,SAAS,SAAS,SAAS,MAAM;AACjC,uBAAW,SAAS,MAAM,GAAG,MAAM;AAAA;AAEnC,oBAAQ;AAAA,eAEX;AACD,sBAAY;AAAA;AAEhB;AAAA,WACC;AAED;AACA,gBAAQ;AAER,YAAI,SAAS,OAAO,SAAS,OAAO,SAAS;AACzC;AACJ;AAAA;AAEA,cAAM;AACN;AAAA;AAAA;AAGZ,MAAI,UAAU;AACV,UAAM,uCAAuC;AACjD;AACA;AAEA,SAAO;AAAA;AAGX,kCAAkC,QAAQ,QAAQ,SAAS;AACvD,QAAM,SAAS,eAAe,aAAa,OAAO,OAAO;AAEzD,MAAK,MAAwC;AACzC,UAAM,eAAe,IAAI;AACzB,eAAW,OAAO,OAAO,MAAM;AAC3B,UAAI,aAAa,IAAI,IAAI;AACrB,cAAK,sCAAsC,IAAI,mBAAmB,OAAO;AAC7E,mBAAa,IAAI,IAAI;AAAA;AAAA;AAG7B,QAAM,UAAU,OAAO,QAAQ;AAAA,IAC3B;AAAA,IACA;AAAA,IAEA,UAAU;AAAA,IACV,OAAO;AAAA;AAEX,MAAI,QAAQ;AAIR,QAAI,CAAC,QAAQ,OAAO,YAAY,CAAC,OAAO,OAAO;AAC3C,aAAO,SAAS,KAAK;AAAA;AAE7B,SAAO;AAAA;AAGX,6BAA6B,QAAQ,eAAe;AAEhD,QAAM,WAAW;AACjB,QAAM,aAAa,IAAI;AACvB,kBAAgB,aAAa,EAAE,QAAQ,OAAO,KAAK,MAAM,WAAW,SAAS;AAC7E,4BAA0B,MAAM;AAC5B,WAAO,WAAW,IAAI;AAAA;AAE1B,oBAAkB,QAAQ,QAAQ,gBAAgB;AAE9C,QAAI,YAAY,CAAC;AACjB,QAAI,uBAAuB,qBAAqB;AAEhD,yBAAqB,UAAU,kBAAkB,eAAe;AAChE,UAAM,UAAU,aAAa,eAAe;AAE5C,UAAM,oBAAoB;AAAA,MACtB;AAAA;AAEJ,QAAI,WAAW,QAAQ;AACnB,YAAM,UAAU,OAAO,OAAO,UAAU,WAAW,CAAC,OAAO,SAAS,OAAO;AAC3E,iBAAW,SAAS,SAAS;AACzB,0BAAkB,KAAK,OAAO,IAAI,sBAAsB;AAAA,UAGpD,YAAY,iBACN,eAAe,OAAO,aACtB,qBAAqB;AAAA,UAC3B,MAAM;AAAA,UAEN,SAAS,iBACH,eAAe,SACf;AAAA;AAAA;AAAA;AAIlB,QAAI;AACJ,QAAI;AACJ,eAAW,oBAAoB,mBAAmB;AAC9C,UAAI,EAAE,SAAS;AAIf,UAAI,UAAU,KAAK,OAAO,KAAK;AAC3B,YAAI,aAAa,OAAO,OAAO;AAC/B,YAAI,kBAAkB,WAAW,WAAW,SAAS,OAAO,MAAM,KAAK;AACvE,yBAAiB,OACb,OAAO,OAAO,OAAQ,SAAQ,kBAAkB;AAAA;AAGxD,gBAAU,yBAAyB,kBAAkB,QAAQ;AAC7D,UAAK,AAA0C,UAAU,KAAK,OAAO;AACjE,yCAAiC,SAAS;AAG9C,UAAI,gBAAgB;AAChB,uBAAe,MAAM,KAAK;AAC1B,YAAK,MAAwC;AACzC,0BAAgB,gBAAgB;AAAA;AAAA,aAGnC;AAED,0BAAkB,mBAAmB;AACrC,YAAI,oBAAoB;AACpB,0BAAgB,MAAM,KAAK;AAG/B,YAAI,aAAa,OAAO,QAAQ,CAAC,cAAc;AAC3C,sBAAY,OAAO;AAAA;AAE3B,UAAI,cAAc,sBAAsB;AACpC,YAAI,WAAW,qBAAqB;AACpC,iBAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,mBAAS,SAAS,IAAI,SAAS,kBAAkB,eAAe,SAAS;AAAA;AAAA;AAKjF,uBAAiB,kBAAkB;AACnC,oBAAc;AAAA;AAElB,WAAO,kBACD,MAAM;AAEJ,kBAAY;AAAA,QAEd;AAAA;AAEV,uBAAqB,YAAY;AAC7B,QAAI,YAAY,aAAa;AACzB,YAAM,UAAU,WAAW,IAAI;AAC/B,UAAI,SAAS;AACT,mBAAW,OAAO;AAClB,iBAAS,OAAO,SAAS,QAAQ,UAAU;AAC3C,gBAAQ,SAAS,QAAQ;AACzB,gBAAQ,MAAM,QAAQ;AAAA;AAAA,WAGzB;AACD,UAAI,QAAQ,SAAS,QAAQ;AAC7B,UAAI,QAAQ,IAAI;AACZ,iBAAS,OAAO,OAAO;AACvB,YAAI,WAAW,OAAO;AAClB,qBAAW,OAAO,WAAW,OAAO;AACxC,mBAAW,SAAS,QAAQ;AAC5B,mBAAW,MAAM,QAAQ;AAAA;AAAA;AAAA;AAIrC,uBAAqB;AACjB,WAAO;AAAA;AAEX,yBAAuB,SAAS;AAC5B,QAAI,IAAI;AAER,WAAO,IAAI,SAAS,UAChB,uBAAuB,SAAS,SAAS,OAAO;AAChD;AAGJ,aAAS,OAAO,GAAG,GAAG;AAEtB,QAAI,QAAQ,OAAO,QAAQ,CAAC,cAAc;AACtC,iBAAW,IAAI,QAAQ,OAAO,MAAM;AAAA;AAQ5C,mBAAiB,WAAU,iBAAiB;AACxC,QAAI;AACJ,QAAI,SAAS;AACb,QAAI;AACJ,QAAI;AACJ,QAAI,UAAU,aAAY,UAAS,MAAM;AACrC,gBAAU,WAAW,IAAI,UAAS;AAClC,UAAI,CAAC;AACD,cAAM,kBAAkB,GAA2B;AAAA,UAC/C;AAAA;AAER,aAAO,QAAQ,OAAO;AACtB,eAAS,OAET,mBAAmB,gBAAgB,QAAQ,QAAQ,KAAK,IAAI,OAAK,EAAE,QAAQ,UAAS;AAEpF,aAAO,QAAQ,UAAU;AAAA,eAEpB,UAAU,WAAU;AAGzB,aAAO,UAAS;AAChB,UAA+C,KAAK,OAAO,KAAK;AAC5D,cAAK,2DAA2D,wDAAwD;AAAA;AAE5H,gBAAU,SAAS,KAAK,OAAK,EAAE,GAAG,KAAK;AAEvC,UAAI,SAAS;AAET,iBAAS,QAAQ,MAAM;AACvB,eAAO,QAAQ,OAAO;AAAA;AAAA,WAIzB;AAED,gBAAU,gBAAgB,OACpB,WAAW,IAAI,gBAAgB,QAC/B,SAAS,KAAK,OAAK,EAAE,GAAG,KAAK,gBAAgB;AACnD,UAAI,CAAC;AACD,cAAM,kBAAkB,GAA2B;AAAA,UAC/C;AAAA,UACA;AAAA;AAER,aAAO,QAAQ,OAAO;AAGtB,eAAS,OAAO,IAAI,gBAAgB,QAAQ,UAAS;AACrD,aAAO,QAAQ,UAAU;AAAA;AAE7B,UAAM,UAAU;AAChB,QAAI,gBAAgB;AACpB,WAAO,eAAe;AAElB,cAAQ,QAAQ,cAAc;AAC9B,sBAAgB,cAAc;AAAA;AAElC,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,MAAM,gBAAgB;AAAA;AAAA;AAI9B,SAAO,QAAQ,WAAS,SAAS;AACjC,SAAO,EAAE,UAAU,SAAS,aAAa,WAAW;AAAA;AAExD,4BAA4B,QAAQ,MAAM;AACtC,MAAI,YAAY;AAChB,WAAS,OAAO,MAAM;AAClB,QAAI,OAAO;AACP,gBAAU,OAAO,OAAO;AAAA;AAEhC,SAAO;AAAA;AAQX,8BAA8B,QAAQ;AAClC,SAAO;AAAA,IACH,MAAM,OAAO;AAAA,IACb,UAAU,OAAO;AAAA,IACjB,MAAM,OAAO;AAAA,IACb,MAAM,OAAO,QAAQ;AAAA,IACrB,SAAS;AAAA,IACT,aAAa,OAAO;AAAA,IACpB,OAAO,qBAAqB;AAAA,IAC5B,UAAU,OAAO,YAAY;AAAA,IAC7B,WAAW;AAAA,IACX,aAAa;AAAA,IACb,cAAc;AAAA,IACd,gBAAgB;AAAA,IAChB,YAAY,gBAAgB,SACtB,OAAO,cAAc,KACrB,EAAE,SAAS,OAAO;AAAA;AAAA;AAQhC,8BAA8B,QAAQ;AAClC,QAAM,cAAc;AAEpB,QAAM,QAAQ,OAAO,SAAS;AAC9B,MAAI,eAAe,QAAQ;AACvB,gBAAY,UAAU;AAAA,SAErB;AAGD,aAAS,QAAQ,OAAO;AACpB,kBAAY,QAAQ,OAAO,UAAU,YAAY,QAAQ,MAAM;AAAA;AAEvE,SAAO;AAAA;AAMX,uBAAuB,QAAQ;AAC3B,SAAO,QAAQ;AACX,QAAI,OAAO,OAAO;AACd,aAAO;AACX,aAAS,OAAO;AAAA;AAEpB,SAAO;AAAA;AAOX,yBAAyB,SAAS;AAC9B,SAAO,QAAQ,OAAO,CAAC,MAAM,WAAW,OAAO,MAAM,OAAO,OAAO;AAAA;AAEvE,sBAAsB,UAAU,gBAAgB;AAC5C,MAAI,UAAU;AACd,WAAS,OAAO,UAAU;AACtB,YAAQ,OACJ,OAAO,iBAAiB,eAAe,OAAO,SAAS;AAAA;AAE/D,SAAO;AAAA;AAEX,qBAAqB,GAAG,GAAG;AACvB,SAAQ,EAAE,SAAS,EAAE,QACjB,EAAE,aAAa,EAAE,YACjB,EAAE,eAAe,EAAE;AAAA;AAE3B,yBAAyB,GAAG,GAAG;AAC3B,WAAS,OAAO,EAAE,MAAM;AACpB,QAAI,CAAC,EAAE,KAAK,KAAK,YAAY,KAAK,MAAM;AACpC,aAAO,MAAK,UAAU,EAAE,OAAO,mCAAmC,EAAE,OAAO,iDAAiD,IAAI;AAAA;AAExI,WAAS,OAAO,EAAE,MAAM;AACpB,QAAI,CAAC,EAAE,KAAK,KAAK,YAAY,KAAK,MAAM;AACpC,aAAO,MAAK,UAAU,EAAE,OAAO,mCAAmC,EAAE,OAAO,iDAAiD,IAAI;AAAA;AAAA;AAG5I,0CAA0C,QAAQ,QAAQ;AACtD,WAAS,OAAO,OAAO,MAAM;AACzB,QAAI,CAAC,OAAO,KAAK,KAAK,YAAY,KAAK,MAAM;AACzC,aAAO,MAAK,kBAAkB,OAAO,OAAO,iDAAiD,IAAI,wBAAwB,OAAO,OAAO;AAAA;AAAA;AAOnJ,wBAAwB;AACpB,MAAI,WAAW;AACf,eAAa,SAAS;AAClB,aAAS,KAAK;AACd,WAAO,MAAM;AACT,YAAM,IAAI,SAAS,QAAQ;AAC3B,UAAI,IAAI;AACJ,iBAAS,OAAO,GAAG;AAAA;AAAA;AAG/B,mBAAiB;AACb,eAAW;AAAA;AAEf,SAAO;AAAA,IACH;AAAA,IACA,MAAM,MAAM;AAAA,IACZ;AAAA;AAAA;AAWR,4BAA4B,YAAY;AACpC,QAAM,WAAW;AACjB,MAAI,CAAC,UAAU;AACX,IACI,KAAO;AACX;AAAA;AAEJ,QAAM,eAAe,OAAO,iBAAiB,IAAI;AACjD,MAAI,CAAC,cAAc;AACf,IACI,KAAO;AACX;AAAA;AAEJ,eAAa,YAAY,KAEzB,WAAW,KAAK,SAAS;AAAA;AAS7B,6BAA6B,aAAa;AACtC,QAAM,WAAW;AACjB,MAAI,CAAC,UAAU;AACX,IACI,KAAO;AACX;AAAA;AAEJ,QAAM,eAAe,OAAO,iBAAiB,IAAI;AACjD,MAAI,CAAC,cAAc;AACf,IACI,KAAO;AACX;AAAA;AAEJ,eAAa,aAAa,KAE1B,YAAY,KAAK,SAAS;AAAA;AAE9B,0BAA0B,OAAO,IAAI,MAAM,QAAQ,MAAM;AAErD,QAAM,qBAAqB,UAEtB,QAAO,eAAe,QAAQ,OAAO,eAAe,SAAS;AAClE,SAAO,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC1C,UAAM,OAAO,CAAC,UAAU;AACpB,UAAI,UAAU;AACV,eAAO,kBAAkB,GAA4B;AAAA,UACjD;AAAA,UACA;AAAA;AAAA,eAEC,iBAAiB,OAAO;AAC7B,eAAO;AAAA,iBAEF,gBAAgB,QAAQ;AAC7B,eAAO,kBAAkB,GAAmC;AAAA,UACxD,MAAM;AAAA,UACN,IAAI;AAAA;AAAA,aAGP;AACD,YAAI,sBAEA,OAAO,eAAe,UAAU,sBAChC,OAAO,UAAU;AACjB,6BAAmB,KAAK;AAC5B;AAAA;AAAA;AAIR,QAAI,YAAY,QAAQ,QAAQ,MAAM,KAAK,UAAU,OAAO,UAAU,OAAO,IAAI,MAAO,OAAyC,oBAAoB,MAAM,IAAI,QAAQ;AACvK,QAAI,MAAM,SAAS;AACf,gBAAU,KAAK;AACnB,cAAU,MAAM,SAAO,OAAO;AAAA;AAAA;AAGtC,6BAA6B,MAAM,IAAI,MAAM;AACzC,MAAI,SAAS;AACb,SAAO,WAAY;AACf,QAAI,aAAa;AACb,WAAO,0FAA0F,KAAK,iBAAiB,GAAG;AAC9H,QAAI,WAAW;AACX,WAAK,MAAM,MAAM;AAAA;AAAA;AAG7B,iCAAiC,SAAS,WAAW,IAAI,MAAM;AAC3D,QAAM,SAAS;AACf,aAAW,UAAU,SAAS;AAC1B,eAAW,QAAQ,OAAO,YAAY;AAClC,UAAI,eAAe,OAAO,WAAW;AAErC,UAA+C,UAAU,cAAc;AACnE,aAAO,cAAc,8BAA8B,OAAO;AAC1D,YAAI,UAAU;AACd,uBAAe,MAAM;AAAA;AAGzB,UAAI,cAAc,sBAAsB,CAAC,OAAO,UAAU;AACtD;AACJ,UAAI,iBAAiB,eAAe;AAEhC,YAAI,UAAU,aAAa,aAAa;AACxC,cAAM,QAAQ,QAAQ;AACtB,iBAAS,OAAO,KAAK,iBAAiB,OAAO,IAAI,MAAM,QAAQ;AAAA,aAE9D;AAED,YAAI,mBAAmB;AACvB,YAA+C,CAAE,YAAW,mBAAmB;AAC3E,eAAO,cAAc,8BAA8B,OAAO;AAC1D,6BAAmB,QAAQ,QAAQ;AAAA,eAElC;AACD,6BAAmB,iBAAiB,MAAM,MAAM;AAAA;AAEpD,eAAO,KAAK,MAAM,iBAAiB,KAAK,cAAY;AAChD,cAAI,CAAC;AACD,mBAAO,QAAQ,OAAO,IAAI,MAAM,+BAA+B,6CAA6C,OAAO;AACvH,gBAAM,oBAAoB,WAAW,YAC/B,SAAS,UACT;AAEN,iBAAO,WAAW,QAAQ;AAE1B,gBAAM,QAAQ,kBAAkB;AAChC,iBAAO,SAAS,iBAAiB,OAAO,IAAI,MAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAK1E,SAAO;AAAA;AAMX,0BAA0B,WAAW;AACjC,SAAQ,OAAO,cAAc,YACzB,iBAAiB,aACjB,WAAW,aACX,eAAe;AAAA;AAKvB,iBAAiB,OAAO;AACpB,QAAM,SAAS,OAAO;AACtB,QAAM,eAAe,OAAO;AAC5B,QAAM,QAAQ,SAAS,MAAM,OAAO,QAAQ,MAAM,MAAM;AACxD,QAAM,oBAAoB,SAAS,MAAM;AACrC,QAAI,EAAE,YAAY,MAAM;AACxB,QAAI,EAAE,WAAW;AACjB,UAAM,eAAe,QAAQ,SAAS;AACtC,QAAI,iBAAiB,aAAa;AAClC,QAAI,CAAC,gBAAgB,CAAC,eAAe;AACjC,aAAO;AACX,QAAI,QAAQ,eAAe,UAAU,kBAAkB,KAAK,MAAM;AAClE,QAAI,QAAQ;AACR,aAAO;AAEX,QAAI,mBAAmB,gBAAgB,QAAQ,SAAS;AACxD,WAEA,SAAS,KAGL,gBAAgB,kBAAkB,oBAElC,eAAe,eAAe,SAAS,GAAG,SAAS,mBACjD,eAAe,UAAU,kBAAkB,KAAK,MAAM,QAAQ,SAAS,OACvE;AAAA;AAEV,QAAM,WAAW,SAAS,MAAM,kBAAkB,QAAQ,MACtD,eAAe,aAAa,QAAQ,MAAM,MAAM;AACpD,QAAM,gBAAgB,SAAS,MAAM,kBAAkB,QAAQ,MAC3D,kBAAkB,UAAU,aAAa,QAAQ,SAAS,KAC1D,0BAA0B,aAAa,QAAQ,MAAM,MAAM;AAC/D,oBAAkB,IAAI,IAAI;AACtB,QAAI,WAAW;AACX,aAAO,OAAO,MAAM,MAAM,WAAW,YAAY,QAAQ,MAAM,MAAM;AACzE,WAAO,QAAQ;AAAA;AAEnB,SAAO;AAAA,IACH;AAAA,IACA,MAAM,SAAS,MAAM,MAAM,MAAM;AAAA,IACjC;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAGR,IAAM,iBAAiB,gBAAgB;AAAA,EACnC,MAAM;AAAA,EACN,OAAO;AAAA,IACH,IAAI;AAAA,MACA,MAAM,CAAC,QAAQ;AAAA,MACf,UAAU;AAAA;AAAA,IAEd,aAAa;AAAA,IAEb,kBAAkB;AAAA,IAClB,QAAQ;AAAA;AAAA,EAEZ,MAAM,OAAO,EAAE,OAAO,SAAS;AAC3B,UAAM,OAAO,SAAS,QAAQ;AAC9B,UAAM,EAAE,YAAY,OAAO;AAC3B,UAAM,UAAU,SAAS,MAAO;AAAA,OAC3B,aAAa,MAAM,aAAa,QAAQ,iBAAiB,wBAAwB,KAAK;AAAA,OAMtF,aAAa,MAAM,kBAAkB,QAAQ,sBAAsB,8BAA8B,KAAK;AAAA;AAE3G,WAAO,MAAM;AACT,YAAM,WAAW,MAAM,WAAW,MAAM,QAAQ;AAChD,aAAO,MAAM,SACP,WACA,EAAE,KAAK,OAAO;AAAA,QACZ,gBAAgB,KAAK,gBAAgB,SAAS;AAAA,QAC9C,SAAS,KAAK;AAAA,QACd,MAAM,KAAK;AAAA,SACZ,OAAO;AAAA,QACN,OAAO,QAAQ;AAAA,UACf;AAAA;AAAA;AAAA;AAMpB,IAAM,aAAa;AACnB,oBAAoB,GAAG;AAEnB,MAAI,EAAE,WAAW,EAAE,UAAU,EAAE,WAAW,EAAE;AACxC;AAEJ,MAAI,EAAE;AACF;AAEJ,MAAI,EAAE,WAAW,UAAa,EAAE,WAAW;AACvC;AAGJ,MAAI,EAAE,iBAAiB,EAAE,cAAc,cAAc;AAEjD,UAAM,SAAS,EAAE,cAAc,aAAa;AAC5C,QAAI,cAAc,KAAK;AACnB;AAAA;AAGR,MAAI,EAAE;AACF,MAAE;AACN,SAAO;AAAA;AAEX,wBAAwB,OAAO,OAAO;AAClC,WAAS,OAAO,OAAO;AACnB,QAAI,aAAa,MAAM;AACvB,QAAI,aAAa,MAAM;AACvB,QAAI,OAAO,eAAe,UAAU;AAChC,UAAI,eAAe;AACf,eAAO;AAAA,WAEV;AACD,UAAI,CAAC,MAAM,QAAQ,eACf,WAAW,WAAW,WAAW,UACjC,WAAW,KAAK,CAAC,OAAO,MAAM,UAAU,WAAW;AACnD,eAAO;AAAA;AAAA;AAGnB,SAAO;AAAA;AAMX,yBAAyB,QAAQ;AAC7B,SAAO,SAAU,OAAO,UAAU,OAAO,QAAQ,OAAO,OAAO,OAAQ;AAAA;AAQ3E,IAAI,eAAe,CAAC,WAAW,aAAa,iBAAiB,aAAa,OACpE,YACA,eAAe,OACX,cACA;AAEV,IAAM,iBAAiB,gBAAgB;AAAA,EACnC,MAAM;AAAA,EACN,OAAO;AAAA,IACH,MAAM;AAAA,MACF,MAAM;AAAA,MACN,SAAS;AAAA;AAAA,IAEb,OAAO;AAAA;AAAA,EAEX,MAAM,OAAO,EAAE,OAAO,SAAS;AAC3B,IAA2C;AAC3C,UAAM,QAAQ,OAAO;AACrB,UAAM,QAAQ,OAAO,cAAc;AACnC,UAAM,kBAAkB,SAAS,MAAO,OAAM,SAAS,OAAO,QAAQ;AACtE,YAAQ,cAAc,QAAQ;AAC9B,YAAQ,iBAAiB;AACzB,UAAM,UAAU;AAChB,WAAO,MAAM;AACT,YAAM,eAAe,gBAAgB;AACrC,UAAI,CAAC,cAAc;AACf,eAAO;AAAA;AAEX,YAAM,gBAAgB,aAAa,WAAW,MAAM;AACpD,UAAI,CAAC,eAAe;AAChB,eAAO;AAAA;AAGX,YAAM,mBAAmB,aAAa,MAAM,MAAM;AAClD,YAAM,aAAa,mBACb,qBAAqB,OACjB,MAAM,SACN,OAAO,qBAAqB,aACxB,iBAAiB,SACjB,mBACR;AAGN,YAAM,cAAc,MAAM;AAC1B,YAAM,iBAAiB,MAAM;AACzB,qBAAa,UAAU,eAAe,QAAQ;AAC9C,QAAC,cAAa,eAAe,gBAAgB,IAAI,QAAQ,cAAY,SAAS,QAAQ;AAAA;AAE1F,YAAM,mBAAmB,MAAM;AAE3B,qBAAa,UAAU,eAAe;AAAA;AAE1C,YAAM,YAAY,EAAE,eAAe,OAAO,IAAI,YAAY,OAAO;AAAA,QAC7D;AAAA,QACA;AAAA,QACA,KAAK;AAAA;AAET,aAGA,MAAM,UACA,MAAM,QAAQ,EAAE,WAAW,WAAW,OAAO,kBAC7C;AAAA;AAAA;AAAA;AAMlB,IAAM,aAAa;AAGnB,+BAA+B;AAC3B,QAAM,WAAW;AACjB,QAAM,aAAa,SAAS,UAAU,SAAS,OAAO,KAAK;AAC3D,MAAI,cACC,gBAAe,eAAe,WAAW,SAAS,gBAAgB;AACnE,UAAM,OAAO,eAAe,cAAc,eAAe;AACzD,UAAK;AAAA;AAAA;AAAA;AAAA,KAGK;AAAA;AAAA,MAEC;AAAA;AAAA;AAAA;AAUnB,sBAAsB,SAAS;AAC3B,QAAM,UAAU,oBAAoB,QAAQ,QAAQ;AACpD,MAAI,eAAe,QAAQ,cAAc;AACzC,MAAI,mBAAmB,QAAQ,kBAAkB;AACjD,MAAI,EAAE,mBAAmB;AACzB,MAAI,gBAAgB,QAAQ;AAC5B,QAAM,eAAe;AACrB,QAAM,sBAAsB;AAC5B,QAAM,cAAc;AACpB,QAAM,eAAe,WAAW;AAChC,MAAI,kBAAkB;AAEtB,MAAI,aAAa,kBAAkB,uBAAuB,SAAS;AAC/D,YAAQ,oBAAoB;AAAA;AAEhC,QAAM,kBAAkB,cAAc,KAAK,MAAM,gBAAc,KAAK;AACpE,QAAM,eAAe,cAAc,KAAK,MAAM;AAC9C,QAAM,eAAe,cAAc,KAAK,MAAM;AAC9C,oBAAkB,eAAe,OAAO;AACpC,QAAI;AACJ,QAAI;AACJ,QAAI,YAAY,gBAAgB;AAC5B,eAAS,QAAQ,iBAAiB;AAClC,eAAS;AAAA,WAER;AACD,eAAS;AAAA;AAEb,WAAO,QAAQ,SAAS,QAAQ;AAAA;AAEpC,uBAAqB,MAAM;AACvB,QAAI,gBAAgB,QAAQ,iBAAiB;AAC7C,QAAI,eAAe;AACf,cAAQ,YAAY;AAAA,eAEd,MAAwC;AAC9C,YAAK,qCAAqC,OAAO;AAAA;AAAA;AAGzD,uBAAqB;AACjB,WAAO,QAAQ,YAAY,IAAI,kBAAgB,aAAa;AAAA;AAEhE,oBAAkB,MAAM;AACpB,WAAO,CAAC,CAAC,QAAQ,iBAAiB;AAAA;AAEtC,mBAAiB,aAAa,iBAAiB;AAE3C,sBAAkB,mBAAmB,aAAa;AAClD,QAAI,OAAO,gBAAgB,UAAU;AACjC,UAAI,qBAAqB,SAAS,cAAc,aAAa,gBAAgB;AAC7E,UAAI,gBAAe,QAAQ,QAAQ,EAAE,MAAM,mBAAmB,QAAQ;AACtE,UAAI,QAAO,cAAc,WAAW,mBAAmB;AACvD,UAAK,MAAwC;AACzC,YAAI,MAAK,WAAW;AAChB,gBAAK,aAAa,6BAA6B;AAAA,iBAC1C,CAAC,cAAa,QAAQ,QAAQ;AACnC,gBAAK,0CAA0C;AAAA;AAAA;AAIvD,aAAO,OAAO,oBAAoB,eAAc;AAAA,QAC5C,QAAQ,aAAa,cAAa;AAAA,QAClC,gBAAgB;AAAA,QAChB;AAAA;AAAA;AAGR,QAAI;AAEJ,QAAI,UAAU,aAAa;AACvB,UAAK,AACD,YAAY,eACZ,CAAE,WAAU,gBACZ,OAAO,KAAK,YAAY,QAAQ,QAAQ;AACxC,cAAK,SAAS,YAAY;AAAA;AAE9B,wBAAkB,OAAO,IAAI,aAAa;AAAA,QACtC,MAAM,SAAS,cAAc,YAAY,MAAM,gBAAgB,MAAM;AAAA;AAAA,WAGxE;AACD,wBAAkB,OAAO,IAAI,aAAa;AAAA,QACtC,QAAQ,aAAa,YAAY;AAAA;AAAA;AAGzC,QAAI,eAAe,QAAQ,QAAQ,iBAAiB;AACpD,UAAM,OAAO,WAAW,YAAY,QAAQ;AAC5C,QAAK,AAA0C,QAAQ,CAAC,KAAK,WAAW,MAAM;AAC1E,YAAK,mEAAmE,gBAAgB;AAAA;AAG5F,iBAAa,SACT,YAAY,cACN,gBAAgB,YAAY,UAC5B,aAAa,aAAa;AACpC,UAAM,WAAW,aAAa,kBAAkB,OAAO,IAAI,aAAa;AAAA,MACpE;AAAA,MACA,MAAM,aAAa;AAAA;AAEvB,QAAI,OAAO,cAAc,WAAW;AACpC,QAAK,MAAwC;AACzC,UAAI,KAAK,WAAW;AAChB,cAAK,aAAa,6BAA6B;AAAA,eAC1C,CAAC,aAAa,QAAQ,QAAQ;AACnC,cAAK,0CAA0C,UAAU,cAAc,YAAY,OAAO;AAAA;AAAA;AAGlG,WAAO,OAAO;AAAA,MACV;AAAA,MAGA;AAAA,MACA,OAMA,qBAAqB,iBACf,eAAe,YAAY,SAC3B,YAAY;AAAA,OACnB,cAAc;AAAA,MACb,gBAAgB;AAAA,MAChB;AAAA;AAAA;AAGR,4BAA0B,IAAI;AAC1B,WAAO,OAAO,OAAO,WAAW,EAAE,MAAM,OAAO,OAAO,IAAI;AAAA;AAE9D,mCAAiC,IAAI,MAAM;AACvC,QAAI,oBAAoB,IAAI;AACxB,aAAO,kBAAkB,GAA8B;AAAA,QACnD;AAAA,QACA;AAAA;AAAA;AAAA;AAIZ,gBAAc,IAAI;AACd,WAAO,iBAAiB;AAAA;AAE5B,mBAAiB,IAAI;AACjB,WAAO,KAAK,OAAO,iBAAiB,KAAK,EAAE,SAAS;AAAA;AAExD,4BAA0B,IAAI,gBAAgB;AAC1C,UAAM,iBAAkB,kBAAkB,QAAQ;AAClD,UAAM,OAAO,aAAa;AAC1B,UAAM,OAAO,GAAG;AAChB,UAAM,QAAQ,GAAG;AAEjB,UAAM,WAAU,GAAG,YAAY;AAC/B,UAAM,cAAc,eAAe,QAAQ,eAAe,QAAQ,SAAS;AAC3E,QAAI,eAAe,YAAY,UAAU;AACrC,YAAM,EAAE,aAAa;AAErB,UAAI,oBAAoB,iBAAiB,OAAO,aAAa,aAAa,SAAS,kBAAkB;AACrG,UAAK,AACD,CAAE,WAAU,sBACZ,CAAE,WAAU,oBAAoB;AAChC,cAAK;AAAA,EAA4B,KAAK,UAAU,mBAAmB,MAAM;AAAA,uBAA4B,eAAe;AACpH,eAAO,QAAQ,OAAO,IAAI,MAAM;AAAA;AAEpC,aAAO,iBAAiB,OAAO,IAM/B,gBAAgB,mBAAmB;AAAA,QAC/B,OAAO;AAAA,QACP;AAAA,QACA;AAAA,UAGJ,kBAAkB;AAAA;AAGtB,UAAM,aAAa;AACnB,eAAW,iBAAiB;AAC5B,QAAI;AACJ,QAAI,CAAC,SAAS,oBAAoB,kBAAkB,MAAM,iBAAiB;AACvE,gBAAU,kBAAkB,IAAgC,EAAE,IAAI,YAAY;AAE9E,mBAAa,MAAM,MAGnB,MAGA;AAAA;AAEJ,WAAQ,WAAU,QAAQ,QAAQ,WAAW,SAAS,YAAY,OAC7D,MAAM,CAAC,UAAU;AAClB,UAAI,oBAAoB,OAAO,IAC3B,IACA,IAAoC;AACpC,eAAO;AAAA;AAGX,aAAO,aAAa;AAAA,OAEnB,KAAK,CAAC,aAAY;AACnB,UAAI,UAAS;AACT,YAAI,oBAAoB,UAAS;AAE7B,iBAAO,iBAEP,OAAO,iBAAiB,SAAQ,KAAK;AAAA,YACjC,OAAO;AAAA,YACP;AAAA,YACA;AAAA,cACA,kBAAkB;AAAA,aAEzB;AAED,mBAAU,mBAAmB,YAAY,MAAM,MAAM,UAAS;AAAA;AAElE,uBAAiB,YAAY,MAAM;AACnC,aAAO;AAAA;AAAA;AAQf,4CAA0C,IAAI,MAAM;AAChD,UAAM,QAAQ,wBAAwB,IAAI;AAC1C,WAAO,QAAQ,QAAQ,OAAO,SAAS,QAAQ;AAAA;AAGnD,oBAAkB,IAAI,MAAM;AACxB,QAAI;AAEJ,aAAS,wBAAwB,KAAK,QAAQ,OAAO,YAAU,GAAG,QAAQ,QAAQ,UAAU,GAAG,WAAW,oBAAoB,IAAI;AAClI,UAAM,CAAC,gBAAgB,mBAAoB,uBAAuB,IAAI;AACtE,eAAW,UAAU,gBAAgB;AACjC,iBAAW,SAAS,OAAO,aAAa;AACpC,eAAO,KAAK,iBAAiB,OAAO,IAAI;AAAA;AAAA;AAGhD,UAAM,0BAA0B,iCAAiC,KAAK,MAAM,IAAI;AAChF,WAAO,KAAK;AAEZ,WAAQ,cAAc,QACjB,KAAK,MAAM;AAEZ,eAAS;AACT,iBAAW,SAAS,aAAa,QAAQ;AACrC,eAAO,KAAK,iBAAiB,OAAO,IAAI;AAAA;AAE5C,aAAO,KAAK;AACZ,aAAO,cAAc;AAAA,OAEpB,KAAK,MAAM;AAEZ,eAAS,wBAAwB,GAAG,QAAQ,OAAO,YAAU,KAAK,QAAQ,QAAQ,UAAU,KAAK,qBAAqB,IAAI;AAC1H,iBAAW,UAAU,iBAAiB;AAClC,mBAAW,SAAS,OAAO,cAAc;AACrC,iBAAO,KAAK,iBAAiB,OAAO,IAAI;AAAA;AAAA;AAGhD,aAAO,KAAK;AAEZ,aAAO,cAAc;AAAA,OAEpB,KAAK,MAAM;AAEZ,eAAS;AACT,iBAAW,UAAU,GAAG,SAAS;AAE7B,YAAI,OAAO,eAAe,KAAK,QAAQ,QAAQ,UAAU,GAAG;AACxD,cAAI,MAAM,QAAQ,OAAO,cAAc;AACnC,uBAAW,eAAe,OAAO;AAC7B,qBAAO,KAAK,iBAAiB,aAAa,IAAI;AAAA,iBAEjD;AACD,mBAAO,KAAK,iBAAiB,OAAO,aAAa,IAAI;AAAA;AAAA;AAAA;AAIjE,aAAO,KAAK;AAEZ,aAAO,cAAc;AAAA,OAEpB,KAAK,MAAM;AAGZ,SAAG,QAAQ,QAAQ,YAAW,OAAO,iBAAiB;AAEtD,eAAS,wBAET,GAAG,QAAQ,OAAO,YAAU,KAAK,QAAQ,QAAQ,UAAU,IAAI,oBAAoB,IAAI;AACvF,aAAO,KAAK;AAEZ,aAAO,cAAc;AAAA,OAEpB,KAAK,MAAM;AAEZ,eAAS;AACT,iBAAW,SAAS,oBAAoB,QAAQ;AAC5C,eAAO,KAAK,iBAAiB,OAAO,IAAI;AAAA;AAE5C,aAAO,KAAK;AACZ,aAAO,cAAc;AAAA,OAGpB,MAAM,SAAO,oBAAoB,KAAK,KACrC,MACA,QAAQ,OAAO;AAAA;AAEzB,4BAA0B,IAAI,MAAM,SAAS;AAGzC,eAAW,SAAS,YAAY;AAC5B,YAAM,IAAI,MAAM;AAAA;AAOxB,8BAA4B,YAAY,MAAM,QAAQ,UAAS,MAAM;AAEjE,UAAM,QAAQ,wBAAwB,YAAY;AAClD,QAAI;AACA,aAAO;AACX,UAAM,CAAC,kBAAkB,uBAAuB,YAAY;AAC5D,eAAW,UAAU,gBAAgB;AAEjC,aAAO,cAAc;AACrB,aAAO,eAAe;AAEtB,aAAO,YAAY;AACnB,aAAO,iBAAiB;AAAA;AAG5B,UAAM,oBAAoB,SAAS;AACnC,UAAM,QAAQ,CAAC,YAAY,KAAK,QAAQ;AAGxC,QAAI,QAAQ;AAGR,UAAI,YAAW;AACX,sBAAc,QAAQ,WAAW,UAAU,OAAO;AAAA,UAC9C,QAAQ,qBAAqB,SAAS,MAAM;AAAA,WAC7C;AAAA;AAEH,sBAAc,KAAK,WAAW,UAAU;AAAA;AAGhD,iBAAa,QAAQ;AACrB,iBAAa,YAAY,MAAM,QAAQ;AACvC;AAAA;AAEJ,MAAI;AAEJ,4BAA0B;AACtB,4BAAwB,cAAc,OAAO,CAAC,IAAI,OAAO,SAAS;AAE9D,YAAM,aAAa,QAAQ;AAC3B,wBAAkB;AAClB,YAAM,OAAO,aAAa;AAE1B,UAAI,WAAW;AACX,2BAAmB,aAAa,KAAK,UAAU,KAAK,QAAQ;AAAA;AAEhE,eAAS,YAAY,MAChB,MAAM,CAAC,UAAU;AAClB,YAAI,oBAAoB,OAAO,IAA6B,IAA+B;AACvF,iBAAO;AAAA;AAEX,YAAI,oBAAoB,OAAO,IAAoC;AAE/D,cAAI,KAAK;AACL,0BAAc,GAAG,CAAC,KAAK,OAAO;AAGlC,2BAAiB,MAAM,IAAI,YAEzB,MAAM;AAER,iBAAO,QAAQ;AAAA;AAGnB,YAAI,KAAK;AACL,wBAAc,GAAG,CAAC,KAAK,OAAO;AAElC,eAAO,aAAa;AAAA,SAEnB,KAAK,CAAC,YAAY;AACnB,kBACI,WACI,mBAEA,YAAY,MAAM;AAE1B,YAAI,WAAW,KAAK;AAChB,wBAAc,GAAG,CAAC,KAAK,OAAO;AAClC,yBAAiB,YAAY,MAAM;AAAA,SAElC,MAAM;AAAA;AAAA;AAInB,MAAI,gBAAgB;AACpB,MAAI,gBAAgB;AACpB,MAAI;AAMJ,wBAAsB,OAAO;AACzB,gBAAY;AACZ,kBAAc,OAAO,QAAQ,aAAW,QAAQ;AAChD,WAAO,QAAQ,OAAO;AAAA;AAU1B,qBAAmB;AACf,QAAI,SAAS,aAAa,UAAU;AAChC,aAAO,QAAQ;AACnB,WAAO,IAAI,QAAQ,CAAC,UAAS,WAAW;AACpC,oBAAc,IAAI,CAAC,UAAS;AAAA;AAAA;AAQpC,uBAAqB,KAAK;AACtB,QAAI;AACA;AACJ,YAAQ;AACR;AACA,kBACK,OACA,QAAQ,CAAC,CAAC,UAAS,YAAa,MAAM,OAAO,OAAO;AACzD,kBAAc;AAAA;AAGlB,wBAAsB,IAAI,MAAM,QAAQ,mBAAmB;AACvD,QAAI,CAAC,aAAa,CAAC;AACf,aAAO,QAAQ;AACnB,QAAI,iBAAkB,CAAC,UAAU,uBAAuB,aAAa,GAAG,UAAU,OAC5E,sBAAqB,CAAC,WACpB,QAAQ,SACR,QAAQ,MAAM,UAClB;AACJ,WAAO,WACF,KAAK,MAAM,eAAe,IAAI,MAAM,iBACpC,KAAK,cAAY,YAAY,iBAAiB,WAC9C,MAAM;AAAA;AAEf,cAAY,OAAO;AACf,WAAO,IAAI,QAAQ,CAAC,UAAS,WAAW;AACpC,UAAI,cAAc,cAAc,IAAI,SAAO;AACvC;AACA;AACA,eAAO;AAAA;AAEX,UAAI,kBAAkB,YAAY,IAAI,CAAC,KAAK,OAAO,YAAY;AAC3D;AACA;AACA,iBAAQ;AAAA;AAEZ,oBAAc,GAAG;AAAA;AAAA;AAGzB,MAAI;AACJ,QAAM,gBAAgB,IAAI;AAC1B,QAAM,SAAS;AAAA,IACX;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM,MAAM,GAAG;AAAA,IACf,SAAS,MAAM,GAAG;AAAA,IAClB,YAAY,aAAa;AAAA,IACzB,eAAe,oBAAoB;AAAA,IACnC,WAAW,YAAY;AAAA,IACvB,SAAS,cAAc;AAAA,IACvB;AAAA,IACA,QAAQ,KAAK;AACT,YAAM,UAAS;AACf,UAAI,UAAU,cAAc;AAC5B,UAAI,UAAU,cAAc;AAC5B,UAAI,OAAO,iBAAiB,UAAU;AACtC,aAAO,eAAe,IAAI,OAAO,kBAAkB,UAAU;AAAA,QACzD,KAAK,MAAM,MAAM;AAAA;AAKrB,UAAI,aAGA,CAAC,WACD,aAAa,UAAU,2BAA2B;AAElD,kBAAU;AACV,aAAK,cAAc,UAAU,MAAM,SAAO;AACtC,cAAK;AACD,kBAAK,8CAA8C;AAAA;AAAA;AAG/D,YAAM,gBAAgB;AACtB,eAAS,OAAO,2BAA2B;AAEvC,sBAAc,OAAO,SAAS,MAAM,aAAa,MAAM;AAAA;AAE3D,UAAI,QAAQ,WAAW;AACvB,UAAI,QAAQ,kBAAkB,SAAS;AACvC,UAAI,aAAa,IAAI;AACrB,oBAAc,IAAI;AAClB,UAAI,UAAU,WAAY;AACtB,sBAAc,OAAO;AACrB,YAAI,cAAc,OAAO,GAAG;AACxB;AACA,uBAAa,QAAQ;AACrB,oBAAU;AACV,kBAAQ;AAAA;AAEZ,mBAAW,KAAK,MAAM;AAAA;AAAA;AAAA;AAIlC,SAAO;AAAA;AAEX,uBAAuB,QAAQ;AAC3B,SAAO,OAAO,OAAO,CAAC,SAAS,UAAU,QAAQ,KAAK,MAAM,UAAU,QAAQ;AAAA;AAElF,gCAAgC,IAAI,MAAM;AACtC,QAAM,iBAAiB;AACvB,QAAM,kBAAkB;AACxB,QAAM,kBAAkB;AACxB,QAAM,MAAM,KAAK,IAAI,KAAK,QAAQ,QAAQ,GAAG,QAAQ;AACrD,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,UAAM,aAAa,KAAK,QAAQ;AAChC,QAAI,YAAY;AACZ,UAAI,GAAG,QAAQ,QAAQ,cAAc;AACjC,uBAAe,KAAK;AAAA;AAEpB,wBAAgB,KAAK;AAAA;AAE7B,UAAM,WAAW,GAAG,QAAQ;AAC5B,QAAI,UAAU;AAEV,UAAI,KAAK,QAAQ,QAAQ,YAAY;AACjC,wBAAgB,KAAK;AAAA;AAAA;AAGjC,SAAO,CAAC,gBAAgB,iBAAiB;AAAA;AAG7C,qBAAqB;AACjB,SAAO,OAAO;AAAA;AAElB,oBAAoB;AAChB,SAAO,OAAO;AAAA;",
  "names": []
}
